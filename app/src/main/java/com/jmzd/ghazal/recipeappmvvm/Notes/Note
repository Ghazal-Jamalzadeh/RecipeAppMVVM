توضیح کتابخانه های اضافه شده به پروژه--------------------------------------------------------------
# Calligraphy :
اگر خاطرتون باشه توی فصل های قبلی موقع اضافه کردن فونت تک تک توی تمام ویوها اضافه میکردیم
ولی اضافه شدن فونت توی توست و منوها کلا دردسره
با این کتابخونه یک بار یک کد مختصری میزنیم دیگه نیازی به ست کردن فونت روی تک تک المان ها نیست
خودش به صورت خودکار میاد به بهترین شکل فونت رو توی پروژه ست میکنه

# shimmer :
برای lazy loading استفاده میکنیم

# lottie :
کتابخانه خیلی قدرتمند و خفن
 برای اینکه بتونیم یک سری از انیمیشن ها رو که توسط افتر افکت ساخته میشه پیاده سازی کنیم

# Dynamic sizes  :
همه سایزها رو تا 4k ساپورت میکنه

# read more text view :
از اسمش مشخصه چیکار میکنه

نکته خیلی مهم سینک شدن پروژه:
حتما حتما یادتون باشه
 مخازن مورد نیاز رو در settings.gradle توی dependencyResolutionManagement اضافه کنید.
مخصوصا برای کتابخونه dynamic sizes

معرفی api های استفاده شده در پروژه------------------------------------------------------------------
spoonacular.com
سایت بسیار خوب و مرجع برای دستور پخت انواع غذاهای مختلف
برای استفاده از api ها به صورت رایگان باید ثبت نام کنید توی سایت
https://spoonacular.com/food-api/console#Dashboard
با api key که میده تا 150 ریکوعست در روز رایگانه
که توی داشبوردتون میتونید خیلی راحت آمارتون رو ببینید

5ace23b237e0430590fc4f8f8f0cfc66

آموزش اضافه کردن فونت به کل پروژه توسط Calligraphy--------------------------------------------------
نمیخوایم فونت رو دیگه به صورت دستی یا استایل روی اپ ست کنیم
برای دریافت این لایبرری به صفحه گیت هابش برید
حتما حتما حتما وارد نسخه ۳ کتابخونه بشید
نسخه ۲ دیگه از اندروید ۲۹ به بعد ساپورت نمیشه و کرش میکنه
https://github.com/InflationX/Calligraphy

1 - add library (gradle)
دو تا خط implementation داره که به گریدل اضافه میشه
و دو تا روش استفاده:
برای اینکه روی یک ویوی خاص فونت ست کنیم اتریبیوت xml ی داره
مثلا میخوایم یک ویوی خاص به طور خاص فونت بولد داشته باشه
یا کد کاتلینی برای کل پروژه

2- application class
برای استفاده ازش باید یک کلاس اپلیکیشن درست کنیم و توی متد onCreate ش یک سری کد قرار بدیم
چند تا روش ارايه میکنه برای اینکه فونت رو بدیم به بیلدرش
ما میخوایم به این روش استفاده کنیم
.setDefaultFontPath("fonts/atlas_regular.ttf")
ولی شما هر چقدر توی پروژه بگردید دارکتوری ای به اسم فونتس پیدا نمی کنید
اونی هم که تو ریسورس ها میسازیم اسمش فونته نه فونتس
پس این کجاس؟
نکته اول: این fonts صرفا یک اسمیه که خودمون گذاشتیم
از دیفالت های پروژه نیست یعنی و میتونست هر اسم دلخواه دیگه باشه
ولی این پوشه رو کجا بسازم؟
من که نمیتونم بیام توی res پوشه با اسم دلخواه بسازم
تمام پوشه هاش پوشه های از پیش تعیین شده خود اندرویده

جواب:
اینا دسترسی پیدا میکنن به پوشه Assets شما
پوشه assets از اون پوشه هاییه که به صورت پیش فرض فعال نیست و باید خودمون فعالش کنیم
ما توی استس میتونیم فایل های جانبیمون رو قرار بدیم
مثلا فونت ها
یا مثلا دیدید گاهی روی یک دکمه ای میزنید یک صدایی در میاره اون اپلیکیشنه
یا نوتیفیکیشن اپ با یک صدای خاصی پاپ میشه
این چیزا اکثرا توی است قرار میگیره

project root -> R click -> new folder -> assetsFolder -> sync project
یک فولدر جدید بالای res ایجاد میشه. نه توی res

حالا که assets رو داریم دستمون برای پوشه بندی توش بازه
و پیشنهاد میشه فایل ها رو به صورت پوشه بندی داخلش بذارید

سایت های زیادی برای دانلود فونت وجود داره مثل 1001fonts

اون فونتی که میخواید به صورت عمومی روی همه ویوها اعمال شه رو توی کلاس اپلیکیشن قرار بدید
طبیعتا باید کلاس اپلیکیشن رو در مانیفست معرفی کنید

3- inject into context
باید کدهایی که توی کلاس اپلیکیشن نوشتیم رو تزریق کنیم به کانتکس اصلی پروژه
منظور ما اینجا از تزریق di و هیلت و اینا نیستا
میاد اینو وارد کل کانتکس اپلیکیشن ما میکنه
کد زیر حتما باید توی یک اکتیویتی قرار بگیرد.
@Override
protected void attachBaseContext(Context newBase) {
    super.attachBaseContext(ViewPumpContextWrapper.wrap(newBase));
}
وقتی این کد رو میبریم داخل مین اکتیویتی این به کانتکس این اکتیویتی تزریق میشه
و هر فرگمنتی که توی این اکتیویتی لود شه هم این فونت روش اعمال میشه
ما هم سینگل اکتیویتی هستیم
خب این روی تمام صفحات ما ناخوداگاه اعمال میشه

4- Base Activity
اگه چندین اکتویتی توی یک پروژه داشتیم چی؟
کپی پیست این کد توی چندین اکتیویتی آزاردهنده س
میایم توی پوشه utils یک کلاس درست میکنیم به اسم BaseActivity
و از AppCompatActivity ارث بری میکنیم که خواص اکتیویتی رو داشته باشه
اون کده رو کات میکنیم میاریم اینجا قرار میدیم
توی مین اکتویتی به جای AppCompatActivity از BaseActivity ارث بری میکنیم
و چون BaseActivity از AppCompatActivity ارث بری کرده اوکی میشه

فونت ما روی همه ویوها اعمال میشه به جز تب لایوت که اونم تو نت سرچ کنید اوکی میشه میاره راه حلشو

پیاده سازی تزریق وابستگی مربوط به اینترنت-----------------------------------------------------------
بیش از ۹۵٪ پروژه های اندرویدی برای ارتباط با سرور از رتروفیت استفاده میکنن

به منظور تامین وابستگی های نتورک یک فایلی میسازیم به اسم NetworkProviders
این فایل رو از نوع آبجکت میسازیم
چرا آبجکت؟
گزینه های زیاد و متنوعی داریم وقتی new رو میزنیم

#File
مثلا میشه فایل ساخت
از فایل برای نگهداری constant های اپ میشه استفاده کرد
با برای اکستنشن فانکشن ها
یک چیز کلیه
همه چیز رو میشه داخلش قرار بدی

#Object
از طرفی کاتلین اومده موارد مختلفی رو هم به صورت مجزا در نظر گرفته
کلاس - اینترفیس - آبجکت - ...
زمانی که از آبجکت استفاده میکنیم دسترسی هامون نسبت به زمانی که فایل میسازیم کمتره
اکثرا زمانی از آبجکت استفاده میکنیم که
برای تعریف کانستنت ها یا فانکشن ها استفاده میشه
یکم مرتب تر و دسته بندی شده تر در میاره کارو

موقع استفاده اگه مثلا BASE_URL رو داخل Constants که آبجکت است تعریف کردیم
میتونیم به شکل Constants.BASE_URL استفاده کنیم که نیازی به ایمپورت نداره
یا بیایم به صورت BASE_URL خالی بنویسیم و اون Constants را ایمپورت کنیم
در عمل جفتش یکیه

بعد میایم موارد مربوط به تزریق وابستگی رو پیاده میکنیم
@Module
مشخص میکنه این فایل یک ماژوله
@InstallIn(SingletonComponent::class)
محدوده فعالیت این ماژول را تعیین میکنه
این ماژول من به ازای هر فرگمنت ساخته بشه؟
به ازای هر اکتیویتی ساخته بشه؟
یا یک بار در طول اجرای اپلیکیشن من؟

خی گفتیم تنظیمات رتروفیت بزرگ و سنگینن
و درست نیست که به ازای هر فرگمنت که داره ساخته میشه من یک بار این تنظیمات سنگین رو از اول بسازم
موارد نتورک و دیتابیس سنگینن و حتما باید به صورت سینگل تون تعریف شن

@Provides
گفتیم هر کدوم از اینا که داخل ماژول تعریف میشن
که میخوایم وابستگی هاشو نسبت به هم مشخص کنیم در قالب پرواید تامین و استفاده میکنیم
@Singleton
علاوه بر اون میتونیم برای این فانکشنی که داریم تعریف میکنیم بگیم که سینگلتون باشه یا نباشه

# Retrofit :
موقع تامین وابستگی رتروفیت اگه BASE_URL را تو ورودی ندیم هم میشناسه ها
ولی داریم از تزریق وابستگی استفاده میکنیم کارو باید اصولی پیش برد

ورودی دومش جیسونه
که اگه برید توش میبینید دو تا سازنده داره
اولیش هیچ ورودی ای نمیگیره از شما و دومی یک ورودی gson داره
پس باید جیسون رو تامین کنیم

یک آیتم آپشنال توی رتروفیت تنظیمات کلاینت بود
مثلا رید و رایت چقدر طول بکشه
به صورت پیش فرض ده ثانیه است که خب اصلا چیز درستی نیست
یا برای ست کردن اینترسپتورها نیاز داریم به این
مثل لاگینگ اینترسپتور
باید از okHttpClient استفاده کنیم برای این کارا

پیاده سازی کلاس چک کردن اینترنت----------------------------------------------------------------------
روشی که توی این برنامه اینترنت رو چک میکنیم شباهتای زیادی به روش های قبلی مخصوصا MVI داره ولی همون نیست
بیشتر ترکییبیه از MVVM و MVI

liveData :
https://github.com/Ghazal-Jamalzadeh/DiffUtils/blob/74-Koin/app/livedata/src/main/java/com/jmzd/ghazal/livedata/network/CheckConnection.kt

MVVM:
https://github.com/Ghazal-Jamalzadeh/FoodAppMVVM/blob/master/app/src/main/java/com/jmzd/ghazal/foodappmvvm/utils/CheckConnection.kt

MVI:
https://github.com/Ghazal-Jamalzadeh/FoodAppMVI/blob/master/app/src/main/java/com/jmzd/ghazal/foodappmvi/utils/network/NetworkConnectivity.kt

خب مثل قل میایم از : ConnectivityManager.NetworkCallback ارث بری میکنیم توی این کلاس
که از طریقش میخوایم به وضعیت های اینترنت دسترسی داشته باشیم
برای بیان وضعیت اینترنت یک بولین تعریف میکنیم
چون اینترنت یا وصله یا نیست دیگه...
حالت وسطی نداره
از نوع MutableStateFlow در نظر میگیریم که تقریا معادل همون لایو دیتاست
مقدار دیفالت فالس رو براش در نظر میگیریم

خب حالا برای نوشتن دستوراتمون نیاز به فانکشن داریم
وسط کلاس که نمیشه کد زد... این دانش کاتلینیه
این فانکشن رو اسمش رو میذاریم checkNetworkAvailability و باید پابلیک باشه
چون از همه جای اپ از طریق این فانکشن قراره وضعیت اینترنت رو به دست بیاریم
خروجیش قراره یک MutableStateFlow از نوع بولین باشه

#ConnectivityManager
اگه خاطرتون باشه گقتیم ما یک کلاسی داریم به اسم کانکتیویتی منیجر
داخل این کلاس کانکتیویتی منیجر من میتونم این منیجر مربوط به اینترنت رو داشته باشم
که برم ببینم از کدوم سرویس های اینترنت باید استفاده کنم
که بینم اینترنت توی اون دستگاه وجود داره یا نه
پس وابستگی اول این کلاس مشخص شد برای ما

provideCM
کدش مشابه کد MVI است
همونطور که احتمالا یادتونه گقتیم برای دسترسی به این  کانکتیویتی سرویس نیاز به کانتکس داشتیم
از این طریق میتونیم به سرویس های خود اندروید دسترسی داشته باشیم
بعد با استفاده از کلاس کانتکس میگیم کدوم سرویس رو میخوایم
اندروید سرویس های خیلی زیاد و متنوعی برای صدا دوربین باتری و... دارد

خب بعد تعریف کانکتیویتی منیجر میایم رجیسترش میکنیم
registerNetworkCallback
در اصل وصلش میکنیم به اونجایی که مد نظرمون هس
میخوایم بگیم بیا به فلان کال بک وصل شو

ورودی اولی که از ما میخواد نتورک ریکوعسته
و ورودی دومش نتورک کال بک که تو کلاس ازش ارث بری کردیم و میشه this

provideNR
کدش کمی از MVI مفصل تر است
و اندرویدهای مختلف رو ساپورت کردیم
توی اندروید های بالای P اجازه نداریم مثلا اینو توی بک گراند چک کنیم و باید توی فورگراند باشه
کلا توی اندرویدهای جدید سرویس ها خیلی محدود شدن

خب بعد از تامین وابستگی ها میایم سراغ ادامه کدهامون
اینجا باز باید برای اندرویدهای مختلف کدهای مختلفی بزنیم
اندروید بالای M و زیر M فرق دارن

//Active network
میخوایم اون نتورک هایی که اکتیو هستن رو به کمک منیجر بگیرم
اگه نال بود یعنی هیچ نتورکی وصل نیست و فالس رو میفرستیم
چه زمانی این اتفاق می افته؟
مثلا مشکل سخت افزاری

//Capability
در غیر این صورت اگه اکتیوی وجود داشت
بیا ببین وای فایه سلولاره چیه؟
هر کدومو دیدی ترو بفرست

در نهایت برای اندرویدهای پایین هم کدشو مینویسیم
که مقداری از کد دپریکیت شده
و تو جلسات قبل از این روش استفاده کرده بودیم

onAvailable & onLost :
گفتیم زمانی که از اینا استفاده میکنیم دو تا فانکشن دیگه هم داریم
که باید اورراید شن
اینا رو هم مینویسیم

Kotlin Data Class File From Json-------------------------------------------------------------------
پلاگین بالا را در صورتی که نصب ندارید از قسمت پلاگین های اندروید استدیو نصب کنید

مرور تنظیمات مربوط به پلاگین:
اپیزود 257 دقیقه 17

Local & Remote DataSource---------------------------------------------------------------------------
ما میخوایم به صورت مستقیم از apiServices استفاده نکنیم
میخوایم یک واسطه ای باشه که که اون واسطه
 اگه قراره سمت سرور باشه تمامی اون موارد سمت سرور رو برای ما تامین کنه
 اگه قراره به صورت آفلاین باشه دیتابیس یا هر چیزی تمام موارد مربوط به آفلاین رو برای ما تامین کنه

Repository------------------------------------------------------------------------------------------
میبینه ویومدل چه چیزهایی نیاز داره و میاد تصمیم میگیره اون چیزها قراره از لوکال تامین شه یا ریموت
 میشه کلا لایه دیتا سورس رو نادیده گرفت ولی داشتن دیتاسورس بیشتشر مطابق با قواعد سالید هست
 ما این ها رو به صورت مجزا داشته باشیم
 هر کدوم از کارهایی که میخوایم انجام بدیم در قالب یک سری کلاس هایی باشن که ماهیت یکسانی دارن
 که زمانی که من میخوام از اون کلاس هایی که ماهیت یکسانی دارن استفاده کنم ببفهمم
 که آقا تمامی موارد مربوط به ریموت توی فلان کلاسه و تمامی موارد مربوط به لوکال توی فلان کلاس
 و هر کدوم از موارد یا هر دوش رو اگه خواستیم توی کانستراکتور ریپازیتوری بدیم

نکته:
بهتره برای کلاس های ریپازیتوری بیایم اون اسکوپ مورد نظر رو مشخص کنیم
مثل زمانی که با InstallIn برای کل ماژول یک اسکوپی رو مشخص میکردیم
برای خود پروایدر هم میشد به صورت مجزا اسکوپ مشخص کرد با @
چون بهتره بدونه توی چه محدوده ای فعالیت کنه
و اگر اون محدوده از دسترسش خارج شد در جریان باشه (مثلا اکتیویتی یا فرگمنت مورد نظر)

ActivityRetainedScoped = اسکوپ مربوط به چرخه حیات اکتیویتی
ما هم که سینگل اکتیویتی داریم میریم جلو

اکتیویتی اسکوپ میشه همون لایف سایکل معمولی اکتیویتی
و مثلا موقع چرخش صفحه ری کریت میشه این صفحه
به همین دلیل میومدیم از ویومدل و این چیزا استفاده میکردیم
ولی ActivityRetainedScoped آگاهی کامل داره به اون مواردی که اجازه نمیده اکتیویتی من دوباره ری کریت شه
ما از این حالت که استفاده میکنیم جلوی اون ری کریت شدن اکتیویتی رو هم میگیریم
تقریبا معادل ویومدل اسکوپ هست
برای زمانی که داخل ویومدل نیسستیم ازش استفاده میکنیم

Base Response class---------------------------------------------------------------------------------
اگه خاطرتون باشه ما تا اینجای آموزش روش های مختلفی رو برای هندل کردن ریپازیتوری ویومدل گفتیم
مثلا اینکه  هندل کردن ارور کدها و.. رو گاهی توی ریپازیتوری زدیم گاهی توی ویومدل
ولی بهترین حالت اینه اون چیزایی که میخوایم هندل کنیم مثل ارورها و... کامل توی ویومدل بنویسیم
چرا؟
چون ریپازیتوری وظیفه اش اینه صرفا تصمیم گیرنده و تامین کننده اطلاعات باشه
بهتره که وظیفه دیگه ای بهش محول نکنیم
تحلیل کردن اطلاعات و... کار ویومدله

Network Request---------------------------------------
این کلاس باید از نوع سیلد کلاس باشه چون در لحظه فقط یک حالت از حالت هاش میتونه به وقوع بپیونده
مثلا یا ارور یا ساکسس یا لودینگ

طبیعتا از نوع جنرال هست این کلاس
ورودی های مورد نظر ما چه چیزهایی هستن؟
دیتا با مقدار دیفالت نال
مسیج با مقدار دیفالت نال

لودینگ:
از نوع T هست که بعدا مشخص میشص میشه
{یعنی باید T اینجا مشخص شه}
خروجیش هم میشه نتورک ریکوعستی از نوع همین T که هیچ ورودی ای نداره. جفتش نال

ساکسس:
مجدد T باید مشخص شه
این بار کلاس نتورک ریکوعستی که برگردانده میشه یک دیتا هم داخلش داره

ارور:
مثل قبل T را مشخص میکنیم
مسیج را که میفرستیم
دیتا رو هم میاریم باشه شاید اروری که برمیگرده شامل دیتای خاصی بود که خواستیم نشون بدیم

حالا به جا اینکه دیتا تایپپ لایو دیتاهامون از نوع مدل معمولی باشن
از نوع نتورک ریکوعستی خواهند بود که این دیتا رو تو دلش خواهد داشت

{تو فلاتر من میایم این کلاس جنرال مای رسپانس رو توی دیتاسورس درست میکنم
یعنی در اصل توی دیتاسورس هندل میکنم ارور کدها و ... رو
و این تحلیل و جدا سازی دیتا رو توی ویومدل انجام میدم
به صورتی که ویو شامل کمترین مقدار ایف و الس شه
و صرفا دریافت کننده استیت ها باشه
به نظرم که سیستم خوب و تمیزیه
ولی خل توی MVVM ما یک لایودیتا خواهیم داشت
که همه این حالت ها رو بخوایم توی دل این لایو دیتا پیاده کنیم
روش  اینجا بهتر و تمیز تر از آب در میاد
}

تحلیل و جداسازی ارور کدها---------------------------------------------------------------------------
توی پروژه های قبلی میومدیم این جداسازی ارور کدها رو برای هر api به صورت مجزا مینوشتیم
خب این کار بهینه ای نیست و میخوایم برای این پروژه یک چیز عمومی برای این منظور بنویسیم

NetworkResponse-------------------------------
این کلاس هم یک کلاس جنریک است
و توی ورودی یک ریسپانس از نوع T میگیرد
ریسپانسی که رتروفیت در اختیار ما قرار میدهد
این اطلاعات رو براش میفرستیم و در ازای این اطلاعات این میاد تحلیل میکنه و یک سری اطلاعات دیگه ای در اختیار من قرار میده

از اونجایی که نمیتتونیم مستقیم داخل کلاس کد بزنیم پس یک متد برای این کارها مینویسیم

response.message().contains("timeout")
این api گاهی این ارور را میدهد و مختص رتروفیت و... نیست
احتمالا گاهی توی ساعات ترافیک و این ها باشه ولی خیلی کم پیش میاد
هر ریسپانسی که ما میگیریم یک کد داره و یک مسیج.
این مسیج ها اکثرا یک سری چیزهای روتینن که توسط سرور برامون ساخته میشه
حالا ما چک میکنیم اگه مسیجی که سمتون میاد شامل این کلمه بود بیا یک ارور خاص براش در نظر بگیر

Body Module-----------------------------------------------------------------------------------------
برای تمامی ماژول های مربوط به مدل های بادی یک ماژول مستقل میسازیم
میخواهیم این ماژول در محدوده فرگمنت کار کنه
طبیعتا نمیخوایم به صورت سینگل تون هم باشن پس براشون نمینوسییم سینگل تون

lifecycleScope.launch-------------------------------------------------------------------------------
حالت های مختلف زیادی دارد
مثلا لانچ خالی - حالت جنرال و کلی  <-> lunch
lunchWhenStarted -> وقتی فرگمنت به حالت استارت رسید
lunchWhenResumed -> وقتی فرگمنت به حالت رسیوم رسید
lunchWhenCreated -> وقتی ساخته شد
لایف سایکل را مد نظر قرار میدهد
مثلا میگیم زمانی که این کد رو اجرا میکنی حتما فرگمنت استارت شده باشد

DataStore-------------------------------------------------------------------------------------------
برای دیتا استور از لوکال دیتا سورس استفاده نمیکنیم.
لوکال دیتا سورس رو میاریم برای دیتابیس فقط.
پس چیکار کنیم؟
مگه ریپازیتوری وظیفه تامین کردن اطلاعات رو بر عهده نداشت؟
کدهای مربوط  به تامین اطلاعات از دیتا استور هم داخل ریپازیتوری قرار میگیره

1- define keys
ما الان اینجا قراره دو تا مورد رو ذخیره سازی کنیم
یوزنیم و هش کد
ما الان برای هر کدوم از این ها باید یک سری متغیرهایی داشته باشیم
تا بتونیم این اطلاعات رو  داخل متغیرهایی بریزیم و ذخیره کنیم
برای این موضوع میایم یک آبجکتی رو تعریف میکنیم
و کلیدهامون رو میاریم داخل این آبجکت
که گفتیم دیتا تایپ کلیدی که میخوایم تعریف کنیم رو اینجا تعریف میکنیم.
استرینگه - اینته - هر چی هست

2- define data store
حالا باید بیایم خود دیتا استور رو تعریف کنیم
گفتیم چجوری تعریف میشه؟
روی خود کلاس کانتکس تعریف میشه
و یک کلید کلی هم از ما میخواد که بهش میدیم

3- save method
همه این عملیات رو حالت کروتین میره جلو پس باید ساسپند باشه
مواردی که میخوایم ذخیره شن رو توی ورودی بهش میدیم
حالا میخوایم به دیتا استورمون دسسترسی داشته باشیم
برای دسترسی به دیتا استور باید به کانتکس دسترسی داشته باشیم
کانتکس را از ورودی کلاس تامین میکنیم
(چون این دفعه خود کانتکسه نه کلاس کانتکس)
حالا به اون دیتا استوری که بالا روی کلاس کانتکس تعریف کردیم دسترسی داریم
متد edit را میزنیم
از ریق کلیدها میتونیم ذخیره سازی رو انجام بدیم

4- read
میخوایم کلشو بریزیم در داخل یک متغیر و بعد ازش استفاده کنیم
از نوع فلو هست این متغیر
اینجا باید بهش یک کلاسی رو بدیم
مواردمون رو در واقع داخل یک مدلی میریزیم و میدیم به این فلو
چون یک آیتم که نداریم
چندین آیتم داریم و فلو هم یک دیتا تایپ که بیشتر نمیتونه داشته باشه

خب دوباره از طریق کانتکس به دیتا استور دسترسی پیدا میکنیم
این دفعه از data ش استفاده میکنیم
متد ادیت برای ادیت کردن و نوشتن
متد دیتا برای دسترسی به دیتا و خواندن

خط کد context.dataStore.data چه چیزی رو به ما برمیگردونه
یک فلو از جنس T
: Flow<T>
واسه همین میتونیم روش اپراتور بزنیم
و نهایتا بریزیمش داخل یک فلو دیگه

اول از همه یک catch ی رو براش در نظر میگیریم
فرض میکنیم دیتایی توش نیست و میخوایم بخونیم
خب اپلیکیشن ما نباید کرش کنه
میگیم اگه این اروری که داد از نوع IOException بود
یعنی مربوط به موارد خوندن و سیو کردن بود ارور
بیا emptyPreferences را برای من امیت کن
emptyPreferences :
در واقع یک پرفرنسیز خالی است
هیچ چیزی توش نیست
در غیر این صورت بیا همین اکسپشنی که هست رو برای من پرتاب کن
تا بتونم ازش استفاده کنم

بعد از این میایم از مپ استفاده میکنیم
اگه مپ رو  ننویسیم کلا ارور میده.
چه اروری؟
میگه تو یک متغیر از جنس فلو تعریف کردی
ولی هیچی توش نریختی که
اون کچ هم که خب فلو نیست. فلو نمیسازه
مپ اون محتوای فلو رو برامون return میکنه

6- viewModel
چون ساسپند بودن توی اسکوپ ویومدل بهشون دسترسی پیدا میکنیم
رید که توی متغیر بود رو میریزیم توی یک متغیر از جنس فلو و از هر جای اپ میتونیم بهش دسترسی پیدا کنیم

7- view

دسترسی به ورژن اپلیکیشن در ران تایم-----------------------------------------------------------------
یک کلاسی داریم به اسم BuildConfig
البته به ازای هر کتابخونه ای که هب اپمون اضافه میکنیم هم یک کلاس یلد کانفیگ خواهیم دید
البته نه همه همه کتابخونه ها ولی خیلی هاشون دارن
مثلا رتروفیت نداره
ما باید بیلد کانفیگی رو بگیریم که مربوط میشه به پروژه خودمون
و اسم پکیج خودمون روشه
مواردی که بمون میده شامل
build type -> اینکه نسخه ریلیز هست یا دیباگ
version code -> 1
version name -> 1.0
application id -> پکیج

Shared ViewModel------------------------------------------------------------------------------------
از اینکه از یک ویومدل توی چندین صفحه استفاده کنید
یا توی یک صفحه چندین ویومدل داشته  باشید نترسید
گاهی نیاز میشه
کثلا ممکنه برای یک عملیات جنرال توی کل اپ یک ویومدل در نظر بگیریم و همه جا از همون استفاده کنیم
مثلا توی کل اپ عکس رو به یک روش خاص لود کنیم
چیزهایی که توی کل اپ تکرار میشن
مثلا توی این اپ هر جا میخوایم ببه دیتا استور دسترسی داشته باشیم
از ویومدل رجیستر استفاده میکنیم
و تون کد دیتا استور رو صد جا تکرار نمیکنیم

asLiveData------------------------------------------------------------------------------------------
ما اومدیم دیتا رو از دیتا استور خوندیم که بهمون فلو میده
بعد اینو ریختیم داخل یک متغیر دیگه از جنس فلو
به اسم رید دیتا که داخل ویومدلمون هست
حالا میخوایم تو قالب لایودیتا استفاده کنیم از این اطلاعات
خیلی راحت با کد asLiveData فلو را به لایو دیتا تبدیل میکنیم

پاک کردن یک فرگمنت خاص از استک----------------------------------------------------------------------
نکته ۱ :
حتما حتما کد پاپ کردن بک استک رو قبل از نویگیت کردن ببه صفحه بعد بنویسید

findNavController().popBackStack()
اگر مثل بالا بنویسیم و هیچ چیزی داخل پرانتز ننویسیم
بیشتر توی بک زدن کاربرد داره

findNavController().popBackStack(R.id.splashFragment, true)
میخوام این صفحه ای که داخلش هستم رو ببندم
و باید مشخص کنم این صفحه چیه
آیدی فرگمنت رو میدیم
یک بولین هم میگیره
که میگه چیزی که قراره از استکت پاک شه شامل این فرگمنت هم باشه
که true یعنی پاک شه
{احتمالا با این روش بتونیم از داخل یک فرگمنت فرگمنت دیگه ای رو هم از استک پاک کنیم}

navigate--------------------------------------------------------------------------------------------
موقع نویگیت کردن هم هم میتونیم آیدی اکشن رو بدیم هم آیدی فرگمنت
فرقی نداره
findNavController().navigate(R.id.registerFragment)
findNavController().navigate(R.id.action_to_registerFragment)
ولی اگه اکشن رو قرار بدید مزیتی که داره اینه که اگه لازم داشتید میتونید یک سری دیتای دیگه هم با سیف آرگز بفرستید...

Shimmer RecyclerView--------------------------------------------------------------------------------
کتابخونه شیمر را اد میکنیم
به جای تک ریسایکلر ویوی عادی میایم از تگ شیمر ریسایکلر ویو استفاده میکنیم

app:shimmer_recycler_auto_start="true"
به محض نشون دادنش افکته شروع بشه

app:shimmer_recycler_item_count="1"
تعداد آیتم هایی که میخوایم همون اول به صورت پیش فرض نشون بده

app:shimmer_recycler_shape="linear"
حالت چرخیدن یا انیمیشن شیمر رو میتونیم براش در نظر بگیریم
ما حالت خطی رو در نظر میگیریم

app:shimmer_recycler_layout="@layout/item_popular_shimmer"
باید لایه مربوط به شیمر رو به صورت مجزا بهش بدیم

# shimmer layout طراحی لایه مربوط به شیمر
خب اینحا برامون مهم نیست اون ویویی که دیده میشه عکسه تکسته کارده چیه
صرفا میخوایم طوسی باشه و اون افکت مربوط به شیمر رو ببینیم
سبک ترین ویویی که میتونیم پس زمینه رنگی براش ست کنیم View هست

Emoji By Unicode------------------------------------------------------------------------------------
تمام اموجی ها یک یونکد جهانی دارند
باید یونیکد اون اموجی که میخوایم رو از اینترنت بیاریم و برای کاتلین قابل فهم کنیم
توی متد getEmojiByUnicode توی فرگمنت رسپی کد تبدیل یونیکد به استرینگ هست
بعضی اپلیکیشن ها میان یونیکدهای مخصوص به خودشون رو میسازن مثل تلگرام یا توییتر

RecipeRepository------------------------------------------------------------------------------------
قبلا میومدیم دیتاسورس رو توی کانستراکتور میدادیم بهش
بعد میومدیم همونجا متدی که میخواستیم رو صدا میزدیم مستقیما
 مثل حالتی که توی رجیستر ریپازیتوری نوشتیم

اینجا میخوایم از یک روش دیگه بریم
چرا این کارو میکنیم؟
چون بعدا سر کش کردن دیتا قراره تحت شرایطی از لوکال بخونیم همین دیتا رو
پس ریپازیتوری رو خیلی شلوغ نمیکنیم و فقط به ریموت یا لوکالمون دسترسی ای که لازم داره رو میدیم

بعد میریم توی ویومدل میگیم اگه لوکال میخوای بیا از بخش لوکال ریپازیتوری بردار دیتات رو
در غیر این صورت از ریموت بردار

صرفا در قالب متغیر تعریف میکنیم
البته کاملا میشد مثل قبل هم تعریف کرد. هر دوش درسته ۱۰۰٪
برای دیدن حالت های مختلف مدل های مختلف کد میزنیم

توی مدل جدید یکم کد خلوت تره و ریپازیتوری میگه
این اینه اینم اینه
دیگه کاری ندارم چی رو از کدوم  بخش میخوای
فقط ریموت رو در اختیارت قرار میدم یا فقط لوکال رو در اختیارت قرار میدم
{حس میکنم وقتی لایه دیتاسورس رو داریم این روش روش بهتریه و کد تکراری رو کم میکنه}

تو روش قبلی میگفت مگه نمیخوای فلان چیز رو دسترسی داشته باشی
من خودم تامینش میکنم و مستقیم بهت میدمش همونو

تو روش جدید فقط منبع داده رو میده تو روش قبلی خود داده رو هم میداد

RecipeViewModel-------------------------------------------------------------------------------------
کوعری ها رو میشه داخل ویومدل یا داخل فرگمنت تعریف کرد
ولی بهتره کارهای مربوط به دیتا داخل ویومدل اتفاق بیفته
بعد داخل فرگمنت به این اطلاعات ویومدل دسترسی پیدا میکنیم
کلا بهتره دیتای ما داخل ویومدل باشه همیشه

Base Diff Utils class-------------------------------------------------------------------------------
اگه یادتون بیاد ما دیف یوتیلز رو توی تمام اداپتر ها تعریف میکردیم به صورت جداگانه
اگه دقت میکردید کد دیف یوتیلز توی تمام اداپترها یکسان بود
فقط دیتا تایپ مدل ها تغییر میکرد
پس میتونیم خیلی راحت میتونیم یک کلاس جنرال جنریک برای این کار بنویسیم

کلاس دیف یوتیلز را چطور تعریف میکردیم؟
1-
یک کلاسی مینوشتیم با اسم دلخواه و از  DiffUtil.Callback() ارث بری میکرد

2-
بعد چهار تا متد اورراید میکرد

3-
توی ورودی دو تا لیست رو بهش میدادیم
یک old و یک new
که بررسی آیتم ها و محتواها را با مقایسه این ها انجام میده

4-
این لیست ها را از نوع جنریک تعریف میکنیم

5-
دیف یوتیل اول دو تا سایزها را بررسی میکنه
بعد میاد سراغ areItemsTheSame
اگر یک آیتم مشابه پیدا کنه
میاد کل کانتنت رو با هم بررسی میکنه
یعنی میره سراغ areContentsTheSame
در صورتی که آیتم مشابه پیدا نکنه اصلا سراغ کانتنت نمیره

مثلا فرض کنید ما دو تا کاربر داریم با یک شماره موبایل
توی این حالت آیتم برابر پیدا شده
پس توی قدم بعدی میاد کل کانتنت رو بررسی میکنه
مثلا اسم ها را مقایسه میکنه
اگر همه چیز برابر بود ایگنور میکنه در غیر این صورت در اختیار ما قرار میده

Popular Adapter-------------------------------------------------------------------------------------
1-
گفتیم ویوهلدر را به صورت اینر کلاس تعریف میکنیم که به بایندینگ و سایر آیتم های کلاس اصلی دسترسی داشته باشد

نوع دوم هست این آداپتر

2-
بایندینگ را بالا تعریف میکردیم

3-
لیست رو تعریف میکردیم

4-
میومدیم یک کلاس ست دیتا تعریف میکردیم
که لیست رو پر میکرد و کارهای مربوط به ریسایکلر رو انجام میداد برامون

5-
متدهای مربوط به پر کردن فیلدها را داخل کلاس ویوهلدر به صورت فانکشن با وروردی یک آیتم مینوشتیم
از داخل onBindViewHolder صدا میزدیم

6-
هندل کردن کلیک ها در آداپتر:

میایم یک متغیر تعریف میکنیم از جنس فانکشن
private var onItemClickListener: ((Int) -> Unit)? = null
ورودی و خروجی فانکشن را با توجه به نیازمون مشخص میکنیم

بعد میایم یک متد پابلیک مینویسیم که ورودی این متد از جنس همون فانکشنه
    fun setOnItemClickListener(listener: (Int) -> Unit) {
        onItemClickListener = listener
    }
و مقدار ورودی رو میریزیم داخل اون متغیر

حالا دیگه دسترسی داریم

استفاده ش هم به این شکله با استفاده از  اون متغیره صداش میزنیم و ورودی رو میریزیم توش
 root.setOnClickListener {
                    onItemClickListener?.let { it(item.id!!) }
                }

کد داخلش که داخل فرگمنت یا اکتیویتی هست اجرا میشه


Coil------------------------------------------------------------------------------------------------
لود شدن با انیمیشن
crossfade(true)
crossfade(800)

کش کردن عکس ها در کویل
memoryCachePolicy(CachePolicy.ENABLED)
فشار سمت سرور کم میشه
مصرف اینترنت کاربر میاد پایین
عکس ها سریع تر لود میشن

place holder:
برای وقتایی که عکس به هر دلیلی لود نشه
error(R.drawable.ic_placeholder)

Shimmer Loading-------------------------------------------------------------------------------------
متدهای showShimmer & hideShimmer رو داریم
به جای لودینگ سابق

RecyclerView----------------------------------------------------------------------------------------

setHasFixedSize(true)
برای زمانی است که اندازه آیتم های ریسایکلر ویوی ما ثابت است
یکیشون بلندتر نیست یکیشون کوتاه تر
اینجوری بهتر و سریع تر رندر میشه
به صورت پیش فرض فالس است
یک کمک کوچیکی هست به cpu و gpu
و کمتر لگ میزنه

DiffUtils BUG---------------------------------------------------------------------------------------
ممکنه توی ریسایکلر ویوتون آیتم های تکراری ببینید
که این اتفاق زمان نوتیفی دیتا ست چنجد نمی افتاد
چون همه آیتم ها رو از اول میساخت
و کارهای مربوط به پوزیشن و این ها رو هم خودش انجام میداد و هندل میکرد
وقتی ما داربم از دیف یوتیلز استفاده میکنیم
اون اتفاق نمی افته
یعنی فقط مواردی که میخوایم آپدیت میشه
و این به خاطر پوزیشن هاست
باید وضعیت پووزیشنا رو داشته باشیم که با هم قاطی نشن

این رو با وظایف دیف یوتیلز اشتباه نگیرید ها
دیف یوتیلز صرفا داره اطلاعات رو در داخل آداپتر من نشون میده

این باگ داپلیکیت شدن پوزیشن ها که آیتم های قبلی روی آیتم های جدید قرار میگیرن
چون نوتیفای دیتا سست چنجد هر سری کل آیتم ها را آپدیت میکرد و به همین دلیل هم بود که رفت کنار
فشار زیادی وارد میکرد ولی خب پوزیشنا رو خوب هندل میکرد
حالا که از دیف یوتیلز استفاده میکنیم باید این هندل کردن پوزیشنا رو به صورت دستی قرار بدیم

راه حل:
اورراید کردن این دو تا متد

    override fun getItemViewType(position: Int) = position

    override fun getItemId(position: Int) = position.toLong()

راه حل ۲:
توی فصل های قبلی توی onBindViewHolder میومدیم یک کدی را اضافه میکردیم

holder.setIsRecyclable(false)

این میومد کل زحمات مهندسین ریسایکلر ویو رو میبرد زیر سوال
و عملا شبیه لیست ویو که مال ۹ سال پیشه استفاده میکنیم ازش
پس این کد را میذاریم کنار و از راه حل بهینه اول استفاده میکنیم

Auto Scroll-----------------------------------------------------------------------------------------
برای پیاده سازی این حالت از متد smoothScrollToPosition خود ریسایکلر ویو استفاده میکنیم

میشه از حلقه فور استفاده کرد برای پیاده سازیش
ولی ما میخوایم از فلو و امکانات فلو استفاده کنیم

همچنین لایبرری های متنوعی هم برای infinite scroll وجود داره
معمولا میان چیکار میکنن؟
یک متدی دارن به اسم مکس
مکس اینت میاد بزرگترین عدد اینتیجر ممکن رو میده بهتون
مکس لانگ و مکس دابل و اینا هم داریم...
خلاصه میان این عدد بزرگه رو در میارن
و به این تعداد اسکرول میتونه بخوره ریسایکلر ما
ما اصلا این همه نیاز نداریم مگه یه کاربر چقدر قراره توی صفحه  ما بمونه اصلا

RecipeViewModel-------------------------------------------------------------------------------------
یک متدی داریم توی این ویو مدل به اسم recentNetworkResponse
فلسفه وجودیش چیه؟
ما اون کلاس تفکیک ارور کد ها رو که نوشتیم نمیتونیم توش حالت خالی بودن را بررسی کنیم
چرا؟
چون جنریکه و هر مدلی خالی بودنش با مدل دیگه فرق داره
پس میایم یک متد تفکیک ارور کد اختصاصی برای ریسنت ها مینویسیم...

Themes----------------------------------------------------------------------------------------------
رنگ های سکندری رو کلا از تم پاک کردیم

Animation-------------------------------------------------------------------------------------------
برای آیتم های ریسایکلر میخوایم یک سری انیمیشن در نظر بگیریم

Res -> Rclick -> new -> android resource directory -> anim

انیمیشن مد نظرمون را تعریف میکنیم

حالا میخوایم یکی از بهترین حالت های ست کردن انیمیشن روی ریسایکلر ویو را انجام بدیم
کلا روش های مختلفی داره. ولی این یکی از بهترین حالتاس
وقتی که میاد روی صفحه انیمیشن ساخته میشه و وقتی که میره بیرون از صفحه انیمیشن پاک میشه که توی صفحه نمونه
فقط روی آیتم هایی که فوکوس هستن و روی صفحه هستن انیمیشن اعمال میشه

1-
متدهای initAnimation و clearAnimation را در ویوهلدر مینویسیم

برای ساخت انیمیشن از کلاس AnimationUtils استفاده میکنیم که جزو کلاس های بیسیک خود اندروید هست
که میتونیم انیمیشن رو بهش بدیم و بگیم روی فلان ویوی من این انیمیشنی که ساختم رو اعمال کن

ما اینجا روی روت میزنیم انیمیشن را

برای پاک کردن انیمیشن هم اون ویویی که انیمیشن رو روش زده بودیم دات clearAnimation

2-
حالا کجا از این متدها استفاده کنیم؟
خیلی ها میان تو onBindViewHolder این کار رو انجام میدن
اصلا مناسب نیست
چون حتی وقتی از صفحه خارج میشه آیتم من بازم اون انیمیشن داره پردازش میشه
در حالی که ما از 50 تا آیتم 3 تاشو داریم میبینیم
پس چرا باید توی مموری من بمونه؟

پس میایم از متدهای خاص ریسایکلر ویو برای نشون دادن آیتم و برای از بین رفتن آیتم استفاده میکنیم

به این منظور دو تا متد داریم که میتونیم اورراید کنیم
onViewAttachedToWindow
onViewDetachedFromWindow

میدونید که کدهای داخل onBindViewHolder نسبت به هر آیتم داره اجرا میشه
اون دو تا متد بالا چیکار میکنن؟
میان میبینن صفحه نمایش شما چند اینچه؟ چه رزولیشنی داره؟ چند تا آیتم میتونم نشون بدم توی یک صفحه؟
به ازای هر چند تا آیتمی که میتونه نشون بده متد onViewAttachedToWindow صدا زده میشه
زمانی که اسکرول میکنیم و یکی از آیتم ها از صفحه خارج میشه متد onViewDetachedFromWindow صدا زده میشه
ویو به واسطه اسکرول من از صفحه خارج شده
ساختار ریسایکر ویو خیلی مهمه و باید بشناسیدش

این واقعا یکی از بهترین روش ها برای نمایش انیمیشن در ریسایکلر ویو هست
خیلی عالیه

HTML inside TextView--------------------------------------------------------------------------------
چیجوری html رو داخل تکست ویو نشون بدیم؟ مثلا تگ b و این ها رو
قبلا تکست ویو یک متدی داشت به اسم fromHtml که خب جدیدا یک متد جدید اورده برا این کار و یکم عوض شده

val htmlFormatter = HtmlCompat.fromHtml(item.summary!!, HtmlCompat.FROM_HTML_MODE_COMPACT)
recipeDescTxt.text = htmlFormatter

میایم از کلاس HtmlCompat استفاده میکنیم
دو تا متد داره
toHtml & fromHtml
یکیش این وری تبدیل میکنه یکیشون اون وری
پارامتر اول محتوای html ي ماست که میخوایم نشون بدیم

پارامتر دوم میپرسه به چه شکلی میخوای من اینو تبدیل کنم؟
مربوط به تگ ها و این هاست و زیاد تو حوزه تخصص ما نیست و بیشتر کار فرانت کاراست

حالا ممکنه تگ a داشته باشه که باید کلیکم بخوره
خود تکست ویو به صورت پیش فرض اگه یک موردی به صورت لینک دار باشه میاد اون لینک رو مشخس میکنه
مخصوصا اینجا که ما داریم از اچ تی ام ال استفاده میکنیم
مثلا رنگش رو عوض کنه و این ها

ما الان میخوایم بهش بگیم اون چیزایی که مربوط به لینک هست رو رنگشو عوض نکن
چون پیش فرض میاد رنگ آبی میکنه لینکا رو
ما با اتریبیت زیر بهش میگیم که این  کارو نکنه و رنگ دلخواه خودمون رو بهش میدیم
   android:textColorLink="@color/dolphinGray"

Cash data-------------------------------------------------------------------کش کردن دیتا در اپلیکیشن
تا اینجای کار صفحه اول ما برای حالتی که ایترنت داریم کامل شده
حالا میخوایم شرایطی رو پیاده سازی کنیم که اینترنت وصل نیست
در این حالت باید به جای نشان دادن ارور قطعی اینترنت باید اطلاعات رو از قبل لود کنیم
یک بار که کاربر وارد اپلیکیشن شد و اطلاعات رو گرفت
بدون اینکه کاربر بفهمه ما باید این رو توی دیتابیس ذخیره کنیم
حتما حتما نیاز به دیتابیس داریم و کار دیتا استور و شرد پرفرنس هم نیست
میشه به صورت فایل هم ذخیره کرد که توصیه نمیشه چون سرعت رید و رایتش نسبت به دیتابیس کمه
دردسرهای خاص خودش هم داره

کلا سازو کار کش کردن چیه؟
شما زمانی که میخواید یک چیز به خصوصی رو کش کنید
مثلا برای کش کردن عکس ما از سیستم کش خود کتابخونه استفاده کرده بودیم
ولی به طور کلی ساز و کار کش حالت های مختلفی داره
فقطم توی اندروید نیست این کانسپت کش کردن. توی وب و و ویندوز و ای او اس و سایر پلتفرم ها هست
حالت های مختلف کش کردن خیلی بحث عمیقیه و دانش عمیقی لازم داره که ما کاری نداریم

اکثر اپلیکیشن ها مثل تلگرام و اینستاگرام از دیتابیس برای کش کردن اطلاعات استفاده میکنن
سیستم خیلی بهینه و خوبیه

1- Entity
یک دیتا کلاس تعریف میکنیم و یک آیدی میدیم بهش
و به جای اینکه بقیه فیلدها رو تک به تک اجرا کنیم
 میایم پارامتر دومش رو ریسپانسی که از سرور میاد قرار میدیم
بعدا بنا به شرایط یا این ریپانس مورد نظر از سرور تامین میشه یا از دیتابیس لوکال

سوال؟
حالا از کجا بفهمیم این رسپانسی که ذخیره کردیم مال پاپیلار است یا ریسنت؟
جواب:
از روی آیدی میفهمیم
ما هر چند تا چیز که بخوایم میتونیم داخل تیببل خیره کنیم. درسته؟
ولی ما نمیخوایم کلی چیز ذخیره کنیم که.
اون رسپانسی که داریم ذخیره میکنیم خودش شامل آیدی و لیست و همه چیز هست
ما میایم میگیم من به صورت ذهنی تیبلم رو به دو بخش تقسیم میکنم
اولین بخشش مربوط به پاپیولار - ایندکس ۰
دومین بخشش ریسنت - ایندکس ۱
پس من ای تیبل رو به دو قسمت توی ذهم تقسیم میکنم چون ریسپانس های این ها کاملا یکسانه
بعد اینا قابلیت اورراید داره دیکه. هی رو همون ایندکس مینویسیم باز ریسپانس جدید رو


آیدی رو در نتیجه پرایمری کی میکنیم
ولی نمیخوایم اتو جنریت باشه و میخوایم دست خودمون باشه

2- Dao
چرا اسم کلاس داعو رو گذاشتیم RecipeAppDao ?
چون فقط مختص یک تیبل خاص نیست
میتونیم چندین تیبل داشته باشیم توی این اپ و همه شون هم با همین داعو مدیریت میشه
برای کل اپلیکیشن ماست

ما میدونیم سناریوی کلی ما اینه:
یک صفحه رسپی داریم که قراره کش بشه
یک صفحه فیوریت داریم که قراره کش بشه
یک صفحه دیتیل داریم که قراره کش بشه
هر کدوم از اینا مدل های مختلفی دارن
ولی همه اینا یک دیتابیس و یک داعو خواهند داشت
فقط انتیتی یا تیبل های مختلفی دارن

ما صد تا انتیتی هم که داشته باشیم یک داعو و یک دیتابیس داریم
نیاید اینا رو چند تا بسازید به ازای هر انتیتیی

3- Type Converters
یک نکته خیلی مهمی که وجود داره اینه که
 روم به ما این اجازه رو نمیده که هر چیزی که دلمون میخواد رو توی دیتابیس ذخیره کنیم
مثلا این مدلی که ما الان تعریف کردیم توی دیتابیس روم وجود نداره
توی دیتابیس روم ما به صورت پیش فرض فقط میتونیم از دیتاتایپ های پایه ای واصلی استفاده کنیم
حالا من یک دیتا تایپ کاستوم دارم برای خودم. باید چیکار کنم؟
اصلاحا باید اینو کانورت کنیم و از تایپ کانورترهای مربوط به روم استفاده کنیم
روم برای این بخش قبلا فکر کرده

حالا سناریومون چیه؟
من اول از همه باید این دیتا تایپ رو تبدیل کنم به استرینگ
چرا استرینگ؟
یعنی میایم به کمک جیسون محتواشو تبدیل به یک استرینگ میکنم
در داخل استرینگ نگه میدارم که یکی از دیتا تایپ های اصلی روم است
اینجوری ساختارشم حفظ میشه ولی دیتا تایپشم استرینگ و قابل ذخیره تو روم میشه

برای استفاده ازش باید چیکار کنم؟
دوباره به یک متد دیگه ای هم نیاز دارم
 که اون چیزی که در قالب استرینگ ذخیره کردم رو به صورت جیسون بکشم بیرون
  و هر جا که دلم بخواد هر فیلدیش رو استفاده کنم

من این تایپ کانورتر رو در قالب یک کلاس مینویسم...

4- Type Converter
exportSchema = false
یعنی خروجی جیسون از کل دیتابیس نگیر

سوال:
حالا این تایپ کانورترم رو کجا باید تعریف کنم؟ به کدوم قسمت بدمش؟
جواب:
به همین کلاس دیتابیس
میگیم تویی که داری با این شرایط و این ها دیتابیس من رو میسازی
حواست باشه توی این انتیتی که داری میسازی
من یک دیتا تایپ کاستومی دارم که برای روم تعریف نشده

به این ترتیب تمام کانورترهای من رو خواهد شناخت و وساپورت میکنه

5- DataSource
ریپازیتوری تصمیم میگرفت که این اطلاعات از کجا بیاد
و قبل از اون نیاز به دیتاسورس داشتیم که مطالب بخش آنلاین یا آفلاین رو تامین میکرد
ما تا الان فقط دیتاسورس ریموت داشتیم چون فقط از سرور تامین میشد اطلاعاتمون

6- Repository
ریپازیتوری رجیستر که نیازی به لوکال ندارد همچنان
میریم سر ریپازیتوری رسپی که قراره لوکال رو بهش اضافه کنیم
{رجیستر رو به روش قدیمی و رسپی رو به روش جدید نوشته بودیم}

7- ViewModel
ما یک متد سیو (رایت) میخوایم و یک متد رید
متد سیو ما پرایویت خواهد بود. چرا؟
چون تو همین ویومدل سیو را هندل میکنیم. به فرگمنت و اکتیویتی ما ربطی نداره.
بلافاصبه بعد اینکه ریسپانس api اومد سیو رو انجام میدیم

برای رید کردن:
یک لایو دیتا خواهیم داشت که اطلاعات لود شده از دیتابیس رو داخلش میریزیم
چون ما از دیتابیس به صورت لیست فلو میخوندیم و الان لایو دیتا میخوایم با asLiveData دیتای دریافتی رو تبدیل میکنیم

ما برای سیو کردن دو تا متد مینویسیم که به اصول سالید پایبند باشیم
چون هر متد فقط یک کار باید انجام دهد
متد savePopular که یک انتیتی میگیره و سیو رو انجام میده از طریق ریپازیتوری
متد offlinePopular که ریسپانس رو میگیره و انتیتی رو میسازه و پاس میده به متد سیو
یادآوری:
ما ایندکس 0 را برای پاپیولار در نظر گرفتیم پس به صورت دستی آیدی رو همیشه صفر میدیم

دیتا رو از لایودیتای پاپولار میخونیم که مطمعن باشیم ریسپانس دیتا داره و ارور و اینا نگرفتیم
نال بودن رو هم چک میکنیم حتما

