توضیح کتابخانه های اضافه شده به پروژه--------------------------------------------------------------
# Calligraphy :
اگر خاطرتون باشه توی فصل های قبلی موقع اضافه کردن فونت تک تک توی تمام ویوها اضافه میکردیم
ولی اضافه شدن فونت توی توست و منوها کلا دردسره
با این کتابخونه یک بار یک کد مختصری میزنیم دیگه نیازی به ست کردن فونت روی تک تک المان ها نیست
خودش به صورت خودکار میاد به بهترین شکل فونت رو توی پروژه ست میکنه

# shimmer :
برای lazy loading استفاده میکنیم

# lottie :
کتابخانه خیلی قدرتمند و خفن
 برای اینکه بتونیم یک سری از انیمیشن ها رو که توسط افتر افکت ساخته میشه پیاده سازی کنیم

# Dynamic sizes  :
همه سایزها رو تا 4k ساپورت میکنه

# read more text view :
از اسمش مشخصه چیکار میکنه

نکته خیلی مهم سینک شدن پروژه:
حتما حتما یادتون باشه
 مخازن مورد نیاز رو در settings.gradle توی dependencyResolutionManagement اضافه کنید.
مخصوصا برای کتابخونه dynamic sizes

معرفی api های استفاده شده در پروژه------------------------------------------------------------------
spoonacular.com
سایت بسیار خوب و مرجع برای دستور پخت انواع غذاهای مختلف
برای استفاده از api ها به صورت رایگان باید ثبت نام کنید توی سایت
https://spoonacular.com/food-api/console#Dashboard
با api key که میده تا 150 ریکوعست در روز رایگانه
که توی داشبوردتون میتونید خیلی راحت آمارتون رو ببینید

5ace23b237e0430590fc4f8f8f0cfc66

آموزش اضافه کردن فونت به کل پروژه توسط Calligraphy--------------------------------------------------
نمیخوایم فونت رو دیگه به صورت دستی یا استایل روی اپ ست کنیم
برای دریافت این لایبرری به صفحه گیت هابش برید
حتما حتما حتما وارد نسخه ۳ کتابخونه بشید
نسخه ۲ دیگه از اندروید ۲۹ به بعد ساپورت نمیشه و کرش میکنه
https://github.com/InflationX/Calligraphy

1 - add library (gradle)
دو تا خط implementation داره که به گریدل اضافه میشه
و دو تا روش استفاده:
برای اینکه روی یک ویوی خاص فونت ست کنیم اتریبیوت xml ی داره
مثلا میخوایم یک ویوی خاص به طور خاص فونت بولد داشته باشه
یا کد کاتلینی برای کل پروژه

2- application class
برای استفاده ازش باید یک کلاس اپلیکیشن درست کنیم و توی متد onCreate ش یک سری کد قرار بدیم
چند تا روش ارايه میکنه برای اینکه فونت رو بدیم به بیلدرش
ما میخوایم به این روش استفاده کنیم
.setDefaultFontPath("fonts/atlas_regular.ttf")
ولی شما هر چقدر توی پروژه بگردید دارکتوری ای به اسم فونتس پیدا نمی کنید
اونی هم که تو ریسورس ها میسازیم اسمش فونته نه فونتس
پس این کجاس؟
نکته اول: این fonts صرفا یک اسمیه که خودمون گذاشتیم
از دیفالت های پروژه نیست یعنی و میتونست هر اسم دلخواه دیگه باشه
ولی این پوشه رو کجا بسازم؟
من که نمیتونم بیام توی res پوشه با اسم دلخواه بسازم
تمام پوشه هاش پوشه های از پیش تعیین شده خود اندرویده

جواب:
اینا دسترسی پیدا میکنن به پوشه Assets شما
پوشه assets از اون پوشه هاییه که به صورت پیش فرض فعال نیست و باید خودمون فعالش کنیم
ما توی استس میتونیم فایل های جانبیمون رو قرار بدیم
مثلا فونت ها
یا مثلا دیدید گاهی روی یک دکمه ای میزنید یک صدایی در میاره اون اپلیکیشنه
یا نوتیفیکیشن اپ با یک صدای خاصی پاپ میشه
این چیزا اکثرا توی است قرار میگیره

project root -> R click -> new folder -> assetsFolder -> sync project
یک فولدر جدید بالای res ایجاد میشه. نه توی res

حالا که assets رو داریم دستمون برای پوشه بندی توش بازه
و پیشنهاد میشه فایل ها رو به صورت پوشه بندی داخلش بذارید

سایت های زیادی برای دانلود فونت وجود داره مثل 1001fonts

اون فونتی که میخواید به صورت عمومی روی همه ویوها اعمال شه رو توی کلاس اپلیکیشن قرار بدید
طبیعتا باید کلاس اپلیکیشن رو در مانیفست معرفی کنید

3- inject into context
باید کدهایی که توی کلاس اپلیکیشن نوشتیم رو تزریق کنیم به کانتکس اصلی پروژه
منظور ما اینجا از تزریق di و هیلت و اینا نیستا
میاد اینو وارد کل کانتکس اپلیکیشن ما میکنه
کد زیر حتما باید توی یک اکتیویتی قرار بگیرد.
@Override
protected void attachBaseContext(Context newBase) {
    super.attachBaseContext(ViewPumpContextWrapper.wrap(newBase));
}
وقتی این کد رو میبریم داخل مین اکتیویتی این به کانتکس این اکتیویتی تزریق میشه
و هر فرگمنتی که توی این اکتیویتی لود شه هم این فونت روش اعمال میشه
ما هم سینگل اکتیویتی هستیم
خب این روی تمام صفحات ما ناخوداگاه اعمال میشه

4- Base Activity
اگه چندین اکتویتی توی یک پروژه داشتیم چی؟
کپی پیست این کد توی چندین اکتیویتی آزاردهنده س
میایم توی پوشه utils یک کلاس درست میکنیم به اسم BaseActivity
و از AppCompatActivity ارث بری میکنیم که خواص اکتیویتی رو داشته باشه
اون کده رو کات میکنیم میاریم اینجا قرار میدیم
توی مین اکتویتی به جای AppCompatActivity از BaseActivity ارث بری میکنیم
و چون BaseActivity از AppCompatActivity ارث بری کرده اوکی میشه

فونت ما روی همه ویوها اعمال میشه به جز تب لایوت که اونم تو نت سرچ کنید اوکی میشه میاره راه حلشو

پیاده سازی تزریق وابستگی مربوط به اینترنت-----------------------------------------------------------
بیش از ۹۵٪ پروژه های اندرویدی برای ارتباط با سرور از رتروفیت استفاده میکنن

به منظور تامین وابستگی های نتورک یک فایلی میسازیم به اسم NetworkProviders
این فایل رو از نوع آبجکت میسازیم
چرا آبجکت؟
گزینه های زیاد و متنوعی داریم وقتی new رو میزنیم

#File
مثلا میشه فایل ساخت
از فایل برای نگهداری constant های اپ میشه استفاده کرد
با برای اکستنشن فانکشن ها
یک چیز کلیه
همه چیز رو میشه داخلش قرار بدی

#Object
از طرفی کاتلین اومده موارد مختلفی رو هم به صورت مجزا در نظر گرفته
کلاس - اینترفیس - آبجکت - ...
زمانی که از آبجکت استفاده میکنیم دسترسی هامون نسبت به زمانی که فایل میسازیم کمتره
اکثرا زمانی از آبجکت استفاده میکنیم که
برای تعریف کانستنت ها یا فانکشن ها استفاده میشه
یکم مرتب تر و دسته بندی شده تر در میاره کارو

موقع استفاده اگه مثلا BASE_URL رو داخل Constants که آبجکت است تعریف کردیم
میتونیم به شکل Constants.BASE_URL استفاده کنیم که نیازی به ایمپورت نداره
یا بیایم به صورت BASE_URL خالی بنویسیم و اون Constants را ایمپورت کنیم
در عمل جفتش یکیه

بعد میایم موارد مربوط به تزریق وابستگی رو پیاده میکنیم
@Module
مشخص میکنه این فایل یک ماژوله
@InstallIn(SingletonComponent::class)
محدوده فعالیت این ماژول را تعیین میکنه
این ماژول من به ازای هر فرگمنت ساخته بشه؟
به ازای هر اکتیویتی ساخته بشه؟
یا یک بار در طول اجرای اپلیکیشن من؟

خی گفتیم تنظیمات رتروفیت بزرگ و سنگینن
و درست نیست که به ازای هر فرگمنت که داره ساخته میشه من یک بار این تنظیمات سنگین رو از اول بسازم
موارد نتورک و دیتابیس سنگینن و حتما باید به صورت سینگل تون تعریف شن

@Provides
گفتیم هر کدوم از اینا که داخل ماژول تعریف میشن
که میخوایم وابستگی هاشو نسبت به هم مشخص کنیم در قالب پرواید تامین و استفاده میکنیم
@Singleton
علاوه بر اون میتونیم برای این فانکشنی که داریم تعریف میکنیم بگیم که سینگلتون باشه یا نباشه

# Retrofit :
موقع تامین وابستگی رتروفیت اگه BASE_URL را تو ورودی ندیم هم میشناسه ها
ولی داریم از تزریق وابستگی استفاده میکنیم کارو باید اصولی پیش برد

ورودی دومش جیسونه
که اگه برید توش میبینید دو تا سازنده داره
اولیش هیچ ورودی ای نمیگیره از شما و دومی یک ورودی gson داره
پس باید جیسون رو تامین کنیم

یک آیتم آپشنال توی رتروفیت تنظیمات کلاینت بود
مثلا رید و رایت چقدر طول بکشه
به صورت پیش فرض ده ثانیه است که خب اصلا چیز درستی نیست
یا برای ست کردن اینترسپتورها نیاز داریم به این
مثل لاگینگ اینترسپتور
باید از okHttpClient استفاده کنیم برای این کارا

پیاده سازی کلاس چک کردن اینترنت----------------------------------------------------------------------
روشی که توی این برنامه اینترنت رو چک میکنیم شباهتای زیادی به روش های قبلی مخصوصا MVI داره ولی همون نیست
بیشتر ترکییبیه از MVVM و MVI

liveData :
https://github.com/Ghazal-Jamalzadeh/DiffUtils/blob/74-Koin/app/livedata/src/main/java/com/jmzd/ghazal/livedata/network/CheckConnection.kt

MVVM:
https://github.com/Ghazal-Jamalzadeh/FoodAppMVVM/blob/master/app/src/main/java/com/jmzd/ghazal/foodappmvvm/utils/CheckConnection.kt

MVI:
https://github.com/Ghazal-Jamalzadeh/FoodAppMVI/blob/master/app/src/main/java/com/jmzd/ghazal/foodappmvi/utils/network/NetworkConnectivity.kt

خب مثل قل میایم از : ConnectivityManager.NetworkCallback ارث بری میکنیم توی این کلاس
که از طریقش میخوایم به وضعیت های اینترنت دسترسی داشته باشیم
برای بیان وضعیت اینترنت یک بولین تعریف میکنیم
چون اینترنت یا وصله یا نیست دیگه...
حالت وسطی نداره
از نوع MutableStateFlow در نظر میگیریم که تقریا معادل همون لایو دیتاست
مقدار دیفالت فالس رو براش در نظر میگیریم

خب حالا برای نوشتن دستوراتمون نیاز به فانکشن داریم
وسط کلاس که نمیشه کد زد... این دانش کاتلینیه
این فانکشن رو اسمش رو میذاریم checkNetworkAvailability و باید پابلیک باشه
چون از همه جای اپ از طریق این فانکشن قراره وضعیت اینترنت رو به دست بیاریم
خروجیش قراره یک MutableStateFlow از نوع بولین باشه

#ConnectivityManager
اگه خاطرتون باشه گقتیم ما یک کلاسی داریم به اسم کانکتیویتی منیجر
داخل این کلاس کانکتیویتی منیجر من میتونم این منیجر مربوط به اینترنت رو داشته باشم
که برم ببینم از کدوم سرویس های اینترنت باید استفاده کنم
که بینم اینترنت توی اون دستگاه وجود داره یا نه
پس وابستگی اول این کلاس مشخص شد برای ما

provideCM
کدش مشابه کد MVI است
همونطور که احتمالا یادتونه گقتیم برای دسترسی به این  کانکتیویتی سرویس نیاز به کانتکس داشتیم
از این طریق میتونیم به سرویس های خود اندروید دسترسی داشته باشیم
بعد با استفاده از کلاس کانتکس میگیم کدوم سرویس رو میخوایم
اندروید سرویس های خیلی زیاد و متنوعی برای صدا دوربین باتری و... دارد

خب بعد تعریف کانکتیویتی منیجر میایم رجیسترش میکنیم
registerNetworkCallback
در اصل وصلش میکنیم به اونجایی که مد نظرمون هس
میخوایم بگیم بیا به فلان کال بک وصل شو

ورودی اولی که از ما میخواد نتورک ریکوعسته
و ورودی دومش نتورک کال بک که تو کلاس ازش ارث بری کردیم و میشه this

provideNR
کدش کمی از MVI مفصل تر است
و اندرویدهای مختلف رو ساپورت کردیم
توی اندروید های بالای P اجازه نداریم مثلا اینو توی بک گراند چک کنیم و باید توی فورگراند باشه
کلا توی اندرویدهای جدید سرویس ها خیلی محدود شدن

خب بعد از تامین وابستگی ها میایم سراغ ادامه کدهامون
اینجا باز باید برای اندرویدهای مختلف کدهای مختلفی بزنیم
اندروید بالای M و زیر M فرق دارن

//Active network
میخوایم اون نتورک هایی که اکتیو هستن رو به کمک منیجر بگیرم
اگه نال بود یعنی هیچ نتورکی وصل نیست و فالس رو میفرستیم
چه زمانی این اتفاق می افته؟
مثلا مشکل سخت افزاری

//Capability
در غیر این صورت اگه اکتیوی وجود داشت
بیا ببین وای فایه سلولاره چیه؟
هر کدومو دیدی ترو بفرست

در نهایت برای اندرویدهای پایین هم کدشو مینویسیم
که مقداری از کد دپریکیت شده
و تو جلسات قبل از این روش استفاده کرده بودیم

onAvailable & onLost :
گفتیم زمانی که از اینا استفاده میکنیم دو تا فانکشن دیگه هم داریم
که باید اورراید شن
اینا رو هم مینویسیم

Kotlin Data Class File From Json-------------------------------------------------------------------
پلاگین بالا را در صورتی که نصب ندارید از قسمت پلاگین های اندروید استدیو نصب کنید

مرور تنظیمات مربوط به پلاگین:
اپیزود 257 دقیقه 17

Local & Remote DataSource---------------------------------------------------------------------------
ما میخوایم به صورت مستقیم از apiServices استفاده نکنیم
میخوایم یک واسطه ای باشه که که اون واسطه
 اگه قراره سمت سرور باشه تمامی اون موارد سمت سرور رو برای ما تامین کنه
 اگه قراره به صورت آفلاین باشه دیتابیس یا هر چیزی تمام موارد مربوط به آفلاین رو برای ما تامین کنه

Repository------------------------------------------------------------------------------------------
میبینه ویومدل چه چیزهایی نیاز داره و میاد تصمیم میگیره اون چیزها قراره از لوکال تامین شه یا ریموت
 میشه کلا لایه دیتا سورس رو نادیده گرفت ولی داشتن دیتاسورس بیشتشر مطابق با قواعد سالید هست
 ما این ها رو به صورت مجزا داشته باشیم
 هر کدوم از کارهایی که میخوایم انجام بدیم در قالب یک سری کلاس هایی باشن که ماهیت یکسانی دارن
 که زمانی که من میخوام از اون کلاس هایی که ماهیت یکسانی دارن استفاده کنم ببفهمم
 که آقا تمامی موارد مربوط به ریموت توی فلان کلاسه و تمامی موارد مربوط به لوکال توی فلان کلاس
 و هر کدوم از موارد یا هر دوش رو اگه خواستیم توی کانستراکتور ریپازیتوری بدیم

نکته:
بهتره برای کلاس های ریپازیتوری بیایم اون اسکوپ مورد نظر رو مشخص کنیم
مثل زمانی که با InstallIn برای کل ماژول یک اسکوپی رو مشخص میکردیم
برای خود پروایدر هم میشد به صورت مجزا اسکوپ مشخص کرد با @
چون بهتره بدونه توی چه محدوده ای فعالیت کنه
و اگر اون محدوده از دسترسش خارج شد در جریان باشه (مثلا اکتیویتی یا فرگمنت مورد نظر)

ActivityRetainedScoped = اسکوپ مربوط به چرخه حیات اکتیویتی
ما هم که سینگل اکتیویتی داریم میریم جلو

اکتیویتی اسکوپ میشه همون لایف سایکل معمولی اکتیویتی
و مثلا موقع چرخش صفحه ری کریت میشه این صفحه
به همین دلیل میومدیم از ویومدل و این چیزا استفاده میکردیم
ولی ActivityRetainedScoped آگاهی کامل داره به اون مواردی که اجازه نمیده اکتیویتی من دوباره ری کریت شه
ما از این حالت که استفاده میکنیم جلوی اون ری کریت شدن اکتیویتی رو هم میگیریم
تقریبا معادل ویومدل اسکوپ هست
برای زمانی که داخل ویومدل نیسستیم ازش استفاده میکنیم

Base Response class---------------------------------------------------------------------------------
اگه خاطرتون باشه ما تا اینجای آموزش روش های مختلفی رو برای هندل کردن ریپازیتوری ویومدل گفتیم
مثلا اینکه  هندل کردن ارور کدها و.. رو گاهی توی ریپازیتوری زدیم گاهی توی ویومدل
ولی بهترین حالت اینه اون چیزایی که میخوایم هندل کنیم مثل ارورها و... کامل توی ویومدل بنویسیم
چرا؟
چون ریپازیتوری وظیفه اش اینه صرفا تصمیم گیرنده و تامین کننده اطلاعات باشه
بهتره که وظیفه دیگه ای بهش محول نکنیم
تحلیل کردن اطلاعات و... کار ویومدله

Network Request---------------------------------------
این کلاس باید از نوع سیلد کلاس باشه چون در لحظه فقط یک حالت از حالت هاش میتونه به وقوع بپیونده
مثلا یا ارور یا ساکسس یا لودینگ

طبیعتا از نوع جنرال هست این کلاس
ورودی های مورد نظر ما چه چیزهایی هستن؟
دیتا با مقدار دیفالت نال
مسیج با مقدار دیفالت نال

لودینگ:
از نوع T هست که بعدا مشخص میشص میشه
{یعنی باید T اینجا مشخص شه}
خروجیش هم میشه نتورک ریکوعستی از نوع همین T که هیچ ورودی ای نداره. جفتش نال

ساکسس:
مجدد T باید مشخص شه
این بار کلاس نتورک ریکوعستی که برگردانده میشه یک دیتا هم داخلش داره

ارور:
مثل قبل T را مشخص میکنیم
مسیج را که میفرستیم
دیتا رو هم میاریم باشه شاید اروری که برمیگرده شامل دیتای خاصی بود که خواستیم نشون بدیم

حالا به جا اینکه دیتا تایپپ لایو دیتاهامون از نوع مدل معمولی باشن
از نوع نتورک ریکوعستی خواهند بود که این دیتا رو تو دلش خواهد داشت

{تو فلاتر من میایم این کلاس جنرال مای رسپانس رو توی دیتاسورس درست میکنم
یعنی در اصل توی دیتاسورس هندل میکنم ارور کدها و ... رو
و این تحلیل و جدا سازی دیتا رو توی ویومدل انجام میدم
به صورتی که ویو شامل کمترین مقدار ایف و الس شه
و صرفا دریافت کننده استیت ها باشه
به نظرم که سیستم خوب و تمیزیه
ولی خل توی MVVM ما یک لایودیتا خواهیم داشت
که همه این حالت ها رو بخوایم توی دل این لایو دیتا پیاده کنیم
روش  اینجا بهتر و تمیز تر از آب در میاد
}

تحلیل و جداسازی ارور کدها---------------------------------------------------------------------------
توی پروژه های قبلی میومدیم این جداسازی ارور کدها رو برای هر api به صورت مجزا مینوشتیم
خب این کار بهینه ای نیست و میخوایم برای این پروژه یک چیز عمومی برای این منظور بنویسیم

NetworkResponse-------------------------------
این کلاس هم یک کلاس جنریک است
و توی ورودی یک ریسپانس از نوع T میگیرد
ریسپانسی که رتروفیت در اختیار ما قرار میدهد
این اطلاعات رو براش میفرستیم و در ازای این اطلاعات این میاد تحلیل میکنه و یک سری اطلاعات دیگه ای در اختیار من قرار میده

از اونجایی که نمیتتونیم مستقیم داخل کلاس کد بزنیم پس یک متد برای این کارها مینویسیم

response.message().contains("timeout")
این api گاهی این ارور را میدهد و مختص رتروفیت و... نیست
احتمالا گاهی توی ساعات ترافیک و این ها باشه ولی خیلی کم پیش میاد
هر ریسپانسی که ما میگیریم یک کد داره و یک مسیج.
این مسیج ها اکثرا یک سری چیزهای روتینن که توسط سرور برامون ساخته میشه
حالا ما چک میکنیم اگه مسیجی که سمتون میاد شامل این کلمه بود بیا یک ارور خاص براش در نظر بگیر

Body Module-----------------------------------------------------------------------------------------
برای تمامی ماژول های مربوط به مدل های بادی یک ماژول مستقل میسازیم
میخواهیم این ماژول در محدوده فرگمنت کار کنه
طبیعتا نمیخوایم به صورت سینگل تون هم باشن پس براشون نمینوسییم سینگل تون

lifecycleScope.launch-------------------------------------------------------------------------------
حالت های مختلف زیادی دارد
مثلا لانچ خالی - حالت جنرال و کلی  <-> lunch
lunchWhenStarted -> وقتی فرگمنت به حالت استارت رسید
lunchWhenResumed -> وقتی فرگمنت به حالت رسیوم رسید
lunchWhenCreated -> وقتی ساخته شد
لایف سایکل را مد نظر قرار میدهد
مثلا میگیم زمانی که این کد رو اجرا میکنی حتما فرگمنت استارت شده باشد

DataStore-------------------------------------------------------------------------------------------
برای دیتا استور از لوکال دیتا سورس استفاده نمیکنیم.
لوکال دیتا سورس رو میاریم برای دیتابیس فقط.
پس چیکار کنیم؟
مگه ریپازیتوری وظیفه تامین کردن اطلاعات رو بر عهده نداشت؟
کدهای مربوط  به تامین اطلاعات از دیتا استور هم داخل ریپازیتوری قرار میگیره

1- define keys
ما الان اینجا قراره دو تا مورد رو ذخیره سازی کنیم
یوزنیم و هش کد
ما الان برای هر کدوم از این ها باید یک سری متغیرهایی داشته باشیم
تا بتونیم این اطلاعات رو  داخل متغیرهایی بریزیم و ذخیره کنیم
برای این موضوع میایم یک آبجکتی رو تعریف میکنیم
و کلیدهامون رو میاریم داخل این آبجکت
که گفتیم دیتا تایپ کلیدی که میخوایم تعریف کنیم رو اینجا تعریف میکنیم.
استرینگه - اینته - هر چی هست

2- define data store
حالا باید بیایم خود دیتا استور رو تعریف کنیم
گفتیم چجوری تعریف میشه؟
روی خود کلاس کانتکس تعریف میشه
و یک کلید کلی هم از ما میخواد که بهش میدیم

3- save method
همه این عملیات رو حالت کروتین میره جلو پس باید ساسپند باشه
مواردی که میخوایم ذخیره شن رو توی ورودی بهش میدیم
حالا میخوایم به دیتا استورمون دسسترسی داشته باشیم
برای دسترسی به دیتا استور باید به کانتکس دسترسی داشته باشیم
کانتکس را از ورودی کلاس تامین میکنیم
(چون این دفعه خود کانتکسه نه کلاس کانتکس)
حالا به اون دیتا استوری که بالا روی کلاس کانتکس تعریف کردیم دسترسی داریم
متد edit را میزنیم
از ریق کلیدها میتونیم ذخیره سازی رو انجام بدیم

4- read
میخوایم کلشو بریزیم در داخل یک متغیر و بعد ازش استفاده کنیم
از نوع فلو هست این متغیر
اینجا باید بهش یک کلاسی رو بدیم
مواردمون رو در واقع داخل یک مدلی میریزیم و میدیم به این فلو
چون یک آیتم که نداریم
چندین آیتم داریم و فلو هم یک دیتا تایپ که بیشتر نمیتونه داشته باشه

خب دوباره از طریق کانتکس به دیتا استور دسترسی پیدا میکنیم
این دفعه از data ش استفاده میکنیم
متد ادیت برای ادیت کردن و نوشتن
متد دیتا برای دسترسی به دیتا و خواندن

خط کد context.dataStore.data چه چیزی رو به ما برمیگردونه
یک فلو از جنس T
: Flow<T>
واسه همین میتونیم روش اپراتور بزنیم
و نهایتا بریزیمش داخل یک فلو دیگه

اول از همه یک catch ی رو براش در نظر میگیریم
فرض میکنیم دیتایی توش نیست و میخوایم بخونیم
خب اپلیکیشن ما نباید کرش کنه
میگیم اگه این اروری که داد از نوع IOException بود
یعنی مربوط به موارد خوندن و سیو کردن بود ارور
بیا emptyPreferences را برای من امیت کن
emptyPreferences :
در واقع یک پرفرنسیز خالی است
هیچ چیزی توش نیست
در غیر این صورت بیا همین اکسپشنی که هست رو برای من پرتاب کن
تا بتونم ازش استفاده کنم

بعد از این میایم از مپ استفاده میکنیم
اگه مپ رو  ننویسیم کلا ارور میده.
چه اروری؟
میگه تو یک متغیر از جنس فلو تعریف کردی
ولی هیچی توش نریختی که
اون کچ هم که خب فلو نیست. فلو نمیسازه
مپ اون محتوای فلو رو برامون return میکنه

6- viewModel
چون ساسپند بودن توی اسکوپ ویومدل بهشون دسترسی پیدا میکنیم
رید که توی متغیر بود رو میریزیم توی یک متغیر از جنس فلو و از هر جای اپ میتونیم بهش دسترسی پیدا کنیم

7- view

دسترسی به ورژن اپلیکیشن در ران تایم-----------------------------------------------------------------
یک کلاسی داریم به اسم BuildConfig
البته به ازای هر کتابخونه ای که هب اپمون اضافه میکنیم هم یک کلاس یلد کانفیگ خواهیم دید
البته نه همه همه کتابخونه ها ولی خیلی هاشون دارن
مثلا رتروفیت نداره
ما باید بیلد کانفیگی رو بگیریم که مربوط میشه به پروژه خودمون
و اسم پکیج خودمون روشه
مواردی که بمون میده شامل
build type -> اینکه نسخه ریلیز هست یا دیباگ
version code -> 1
version name -> 1.0
application id -> پکیج

Shared ViewModel------------------------------------------------------------------------------------
از اینکه از یک ویومدل توی چندین صفحه استفاده کنید
یا توی یک صفحه چندین ویومدل داشته  باشید نترسید
گاهی نیاز میشه
کثلا ممکنه برای یک عملیات جنرال توی کل اپ یک ویومدل در نظر بگیریم و همه جا از همون استفاده کنیم
مثلا توی کل اپ عکس رو به یک روش خاص لود کنیم
چیزهایی که توی کل اپ تکرار میشن
مثلا توی این اپ هر جا میخوایم ببه دیتا استور دسترسی داشته باشیم
از ویومدل رجیستر استفاده میکنیم
و تون کد دیتا استور رو صد جا تکرار نمیکنیم

asLiveData------------------------------------------------------------------------------------------
ما اومدیم دیتا رو از دیتا استور خوندیم که بهمون فلو میده
بعد اینو ریختیم داخل یک متغیر دیگه از جنس فلو
به اسم رید دیتا که داخل ویومدلمون هست
حالا میخوایم تو قالب لایودیتا استفاده کنیم از این اطلاعات
خیلی راحت با کد asLiveData فلو را به لایو دیتا تبدیل میکنیم

پاک کردن یک فرگمنت خاص از استک----------------------------------------------------------------------
نکته ۱ :
حتما حتما کد پاپ کردن بک استک رو قبل از نویگیت کردن ببه صفحه بعد بنویسید

findNavController().popBackStack()
اگر مثل بالا بنویسیم و هیچ چیزی داخل پرانتز ننویسیم
بیشتر توی بک زدن کاربرد داره

findNavController().popBackStack(R.id.splashFragment, true)
میخوام این صفحه ای که داخلش هستم رو ببندم
و باید مشخص کنم این صفحه چیه
آیدی فرگمنت رو میدیم
یک بولین هم میگیره
که میگه چیزی که قراره از استکت پاک شه شامل این فرگمنت هم باشه
که true یعنی پاک شه
{احتمالا با این روش بتونیم از داخل یک فرگمنت فرگمنت دیگه ای رو هم از استک پاک کنیم}

navigate--------------------------------------------------------------------------------------------
موقع نویگیت کردن هم هم میتونیم آیدی اکشن رو بدیم هم آیدی فرگمنت
فرقی نداره
findNavController().navigate(R.id.registerFragment)
findNavController().navigate(R.id.action_to_registerFragment)
ولی اگه اکشن رو قرار بدید مزیتی که داره اینه که اگه لازم داشتید میتونید یک سری دیتای دیگه هم با سیف آرگز بفرستید...

Shimmer RecyclerView--------------------------------------------------------------------------------
کتابخونه شیمر را اد میکنیم
به جای تک ریسایکلر ویوی عادی میایم از تگ شیمر ریسایکلر ویو استفاده میکنیم

app:shimmer_recycler_auto_start="true"
به محض نشون دادنش افکته شروع بشه

app:shimmer_recycler_item_count="1"
تعداد آیتم هایی که میخوایم همون اول به صورت پیش فرض نشون بده

app:shimmer_recycler_shape="linear"
حالت چرخیدن یا انیمیشن شیمر رو میتونیم براش در نظر بگیریم
ما حالت خطی رو در نظر میگیریم

app:shimmer_recycler_layout="@layout/item_popular_shimmer"
باید لایه مربوط به شیمر رو به صورت مجزا بهش بدیم

# shimmer layout طراحی لایه مربوط به شیمر
خب اینحا برامون مهم نیست اون ویویی که دیده میشه عکسه تکسته کارده چیه
صرفا میخوایم طوسی باشه و اون افکت مربوط به شیمر رو ببینیم
سبک ترین ویویی که میتونیم پس زمینه رنگی براش ست کنیم View هست

Emoji By Unicode------------------------------------------------------------------------------------
تمام اموجی ها یک یونکد جهانی دارند
باید یونیکد اون اموجی که میخوایم رو از اینترنت بیاریم و برای کاتلین قابل فهم کنیم
توی متد getEmojiByUnicode توی فرگمنت رسپی کد تبدیل یونیکد به استرینگ هست
بعضی اپلیکیشن ها میان یونیکدهای مخصوص به خودشون رو میسازن مثل تلگرام یا توییتر

RecipeRepository------------------------------------------------------------------------------------
قبلا میومدیم دیتاسورس رو توی کانستراکتور میدادیم بهش
بعد میومدیم همونجا متدی که میخواستیم رو صدا میزدیم مستقیما
 مثل حالتی که توی رجیستر ریپازیتوری نوشتیم

اینجا میخوایم از یک روش دیگه بریم
چرا این کارو میکنیم؟
چون بعدا سر کش کردن دیتا قراره تحت شرایطی از لوکال بخونیم همین دیتا رو
پس ریپازیتوری رو خیلی شلوغ نمیکنیم و فقط به ریموت یا لوکالمون دسترسی ای که لازم داره رو میدیم

بعد میریم توی ویومدل میگیم اگه لوکال میخوای بیا از بخش لوکال ریپازیتوری بردار دیتات رو
در غیر این صورت از ریموت بردار

صرفا در قالب متغیر تعریف میکنیم
البته کاملا میشد مثل قبل هم تعریف کرد. هر دوش درسته ۱۰۰٪
برای دیدن حالت های مختلف مدل های مختلف کد میزنیم

توی مدل جدید یکم کد خلوت تره و ریپازیتوری میگه
این اینه اینم اینه
دیگه کاری ندارم چی رو از کدوم  بخش میخوای
فقط ریموت رو در اختیارت قرار میدم یا فقط لوکال رو در اختیارت قرار میدم
{حس میکنم وقتی لایه دیتاسورس رو داریم این روش روش بهتریه و کد تکراری رو کم میکنه}

تو روش قبلی میگفت مگه نمیخوای فلان چیز رو دسترسی داشته باشی
من خودم تامینش میکنم و مستقیم بهت میدمش همونو

تو روش جدید فقط منبع داده رو میده تو روش قبلی خود داده رو هم میداد

RecipeViewModel-------------------------------------------------------------------------------------
کوعری ها رو میشه داخل ویومدل یا داخل فرگمنت تعریف کرد
ولی بهتره کارهای مربوط به دیتا داخل ویومدل اتفاق بیفته
بعد داخل فرگمنت به این اطلاعات ویومدل دسترسی پیدا میکنیم
کلا بهتره دیتای ما داخل ویومدل باشه همیشه

Base Diff Utils class-------------------------------------------------------------------------------
اگه یادتون بیاد ما دیف یوتیلز رو توی تمام اداپتر ها تعریف میکردیم به صورت جداگانه
اگه دقت میکردید کد دیف یوتیلز توی تمام اداپترها یکسان بود
فقط دیتا تایپ مدل ها تغییر میکرد
پس میتونیم خیلی راحت میتونیم یک کلاس جنرال جنریک برای این کار بنویسیم

کلاس دیف یوتیلز را چطور تعریف میکردیم؟
1-
یک کلاسی مینوشتیم با اسم دلخواه و از  DiffUtil.Callback() ارث بری میکرد

2-
بعد چهار تا متد اورراید میکرد

3-
توی ورودی دو تا لیست رو بهش میدادیم
یک old و یک new
که بررسی آیتم ها و محتواها را با مقایسه این ها انجام میده

4-
این لیست ها را از نوع جنریک تعریف میکنیم

5-
دیف یوتیل اول دو تا سایزها را بررسی میکنه
بعد میاد سراغ areItemsTheSame
اگر یک آیتم مشابه پیدا کنه
میاد کل کانتنت رو با هم بررسی میکنه
یعنی میره سراغ areContentsTheSame
در صورتی که آیتم مشابه پیدا نکنه اصلا سراغ کانتنت نمیره

مثلا فرض کنید ما دو تا کاربر داریم با یک شماره موبایل
توی این حالت آیتم برابر پیدا شده
پس توی قدم بعدی میاد کل کانتنت رو بررسی میکنه
مثلا اسم ها را مقایسه میکنه
اگر همه چیز برابر بود ایگنور میکنه در غیر این صورت در اختیار ما قرار میده

Popular Adapter-------------------------------------------------------------------------------------
1-
گفتیم ویوهلدر را به صورت اینر کلاس تعریف میکنیم که به بایندینگ و سایر آیتم های کلاس اصلی دسترسی داشته باشد

نوع دوم هست این آداپتر

2-
بایندینگ را بالا تعریف میکردیم

3-
لیست رو تعریف میکردیم

4-
میومدیم یک کلاس ست دیتا تعریف میکردیم
که لیست رو پر میکرد و کارهای مربوط به ریسایکلر رو انجام میداد برامون

5-
متدهای مربوط به پر کردن فیلدها را داخل کلاس ویوهلدر به صورت فانکشن با وروردی یک آیتم مینوشتیم
از داخل onBindViewHolder صدا میزدیم

6-
هندل کردن کلیک ها در آداپتر:

میایم یک متغیر تعریف میکنیم از جنس فانکشن
private var onItemClickListener: ((Int) -> Unit)? = null
ورودی و خروجی فانکشن را با توجه به نیازمون مشخص میکنیم

بعد میایم یک متد پابلیک مینویسیم که ورودی این متد از جنس همون فانکشنه
    fun setOnItemClickListener(listener: (Int) -> Unit) {
        onItemClickListener = listener
    }
و مقدار ورودی رو میریزیم داخل اون متغیر

حالا دیگه دسترسی داریم

استفاده ش هم به این شکله با استفاده از  اون متغیره صداش میزنیم و ورودی رو میریزیم توش
 root.setOnClickListener {
                    onItemClickListener?.let { it(item.id!!) }
                }

کد داخلش که داخل فرگمنت یا اکتیویتی هست اجرا میشه


Coil------------------------------------------------------------------------------------------------
لود شدن با انیمیشن
crossfade(true)
crossfade(800)

کش کردن عکس ها در کویل
memoryCachePolicy(CachePolicy.ENABLED)
فشار سمت سرور کم میشه
مصرف اینترنت کاربر میاد پایین
عکس ها سریع تر لود میشن

place holder:
برای وقتایی که عکس به هر دلیلی لود نشه
error(R.drawable.ic_placeholder)

Shimmer Loading-------------------------------------------------------------------------------------
متدهای showShimmer & hideShimmer رو داریم
به جای لودینگ سابق

RecyclerView----------------------------------------------------------------------------------------

setHasFixedSize(true)
برای زمانی است که اندازه آیتم های ریسایکلر ویوی ما ثابت است
یکیشون بلندتر نیست یکیشون کوتاه تر
اینجوری بهتر و سریع تر رندر میشه
به صورت پیش فرض فالس است
یک کمک کوچیکی هست به cpu و gpu
و کمتر لگ میزنه

DiffUtils BUG---------------------------------------------------------------------------------------
ممکنه توی ریسایکلر ویوتون آیتم های تکراری ببینید
که این اتفاق زمان نوتیفی دیتا ست چنجد نمی افتاد
چون همه آیتم ها رو از اول میساخت
و کارهای مربوط به پوزیشن و این ها رو هم خودش انجام میداد و هندل میکرد
وقتی ما داربم از دیف یوتیلز استفاده میکنیم
اون اتفاق نمی افته
یعنی فقط مواردی که میخوایم آپدیت میشه
و این به خاطر پوزیشن هاست
باید وضعیت پووزیشنا رو داشته باشیم که با هم قاطی نشن

این رو با وظایف دیف یوتیلز اشتباه نگیرید ها
دیف یوتیلز صرفا داره اطلاعات رو در داخل آداپتر من نشون میده

این باگ داپلیکیت شدن پوزیشن ها که آیتم های قبلی روی آیتم های جدید قرار میگیرن
چون نوتیفای دیتا سست چنجد هر سری کل آیتم ها را آپدیت میکرد و به همین دلیل هم بود که رفت کنار
فشار زیادی وارد میکرد ولی خب پوزیشنا رو خوب هندل میکرد
حالا که از دیف یوتیلز استفاده میکنیم باید این هندل کردن پوزیشنا رو به صورت دستی قرار بدیم

راه حل:
اورراید کردن این دو تا متد

    override fun getItemViewType(position: Int) = position

    override fun getItemId(position: Int) = position.toLong()

راه حل ۲:
توی فصل های قبلی توی onBindViewHolder میومدیم یک کدی را اضافه میکردیم

holder.setIsRecyclable(false)

این میومد کل زحمات مهندسین ریسایکلر ویو رو میبرد زیر سوال
و عملا شبیه لیست ویو که مال ۹ سال پیشه استفاده میکنیم ازش
پس این کد را میذاریم کنار و از راه حل بهینه اول استفاده میکنیم

Auto Scroll-----------------------------------------------------------------------------------------
برای پیاده سازی این حالت از متد smoothScrollToPosition خود ریسایکلر ویو استفاده میکنیم

میشه از حلقه فور استفاده کرد برای پیاده سازیش
ولی ما میخوایم از فلو و امکانات فلو استفاده کنیم

همچنین لایبرری های متنوعی هم برای infinite scroll وجود داره
معمولا میان چیکار میکنن؟
یک متدی دارن به اسم مکس
مکس اینت میاد بزرگترین عدد اینتیجر ممکن رو میده بهتون
مکس لانگ و مکس دابل و اینا هم داریم...
خلاصه میان این عدد بزرگه رو در میارن
و به این تعداد اسکرول میتونه بخوره ریسایکلر ما
ما اصلا این همه نیاز نداریم مگه یه کاربر چقدر قراره توی صفحه  ما بمونه اصلا

RecipeViewModel-------------------------------------------------------------------------------------
یک متدی داریم توی این ویو مدل به اسم recentNetworkResponse
فلسفه وجودیش چیه؟
ما اون کلاس تفکیک ارور کد ها رو که نوشتیم نمیتونیم توش حالت خالی بودن را بررسی کنیم
چرا؟
چون جنریکه و هر مدلی خالی بودنش با مدل دیگه فرق داره
پس میایم یک متد تفکیک ارور کد اختصاصی برای ریسنت ها مینویسیم...

Themes----------------------------------------------------------------------------------------------
رنگ های سکندری رو کلا از تم پاک کردیم

Animation-------------------------------------------------------------------------------------------
برای آیتم های ریسایکلر میخوایم یک سری انیمیشن در نظر بگیریم

Res -> Rclick -> new -> android resource directory -> anim

انیمیشن مد نظرمون را تعریف میکنیم

حالا میخوایم یکی از بهترین حالت های ست کردن انیمیشن روی ریسایکلر ویو را انجام بدیم
کلا روش های مختلفی داره. ولی این یکی از بهترین حالتاس
وقتی که میاد روی صفحه انیمیشن ساخته میشه و وقتی که میره بیرون از صفحه انیمیشن پاک میشه که توی صفحه نمونه
فقط روی آیتم هایی که فوکوس هستن و روی صفحه هستن انیمیشن اعمال میشه

1-
متدهای initAnimation و clearAnimation را در ویوهلدر مینویسیم

برای ساخت انیمیشن از کلاس AnimationUtils استفاده میکنیم که جزو کلاس های بیسیک خود اندروید هست
که میتونیم انیمیشن رو بهش بدیم و بگیم روی فلان ویوی من این انیمیشنی که ساختم رو اعمال کن

ما اینجا روی روت میزنیم انیمیشن را

برای پاک کردن انیمیشن هم اون ویویی که انیمیشن رو روش زده بودیم دات clearAnimation

2-
حالا کجا از این متدها استفاده کنیم؟
خیلی ها میان تو onBindViewHolder این کار رو انجام میدن
اصلا مناسب نیست
چون حتی وقتی از صفحه خارج میشه آیتم من بازم اون انیمیشن داره پردازش میشه
در حالی که ما از 50 تا آیتم 3 تاشو داریم میبینیم
پس چرا باید توی مموری من بمونه؟

پس میایم از متدهای خاص ریسایکلر ویو برای نشون دادن آیتم و برای از بین رفتن آیتم استفاده میکنیم

به این منظور دو تا متد داریم که میتونیم اورراید کنیم
onViewAttachedToWindow
onViewDetachedFromWindow

میدونید که کدهای داخل onBindViewHolder نسبت به هر آیتم داره اجرا میشه
اون دو تا متد بالا چیکار میکنن؟
میان میبینن صفحه نمایش شما چند اینچه؟ چه رزولیشنی داره؟ چند تا آیتم میتونم نشون بدم توی یک صفحه؟
به ازای هر چند تا آیتمی که میتونه نشون بده متد onViewAttachedToWindow صدا زده میشه
زمانی که اسکرول میکنیم و یکی از آیتم ها از صفحه خارج میشه متد onViewDetachedFromWindow صدا زده میشه
ویو به واسطه اسکرول من از صفحه خارج شده
ساختار ریسایکر ویو خیلی مهمه و باید بشناسیدش

این واقعا یکی از بهترین روش ها برای نمایش انیمیشن در ریسایکلر ویو هست
خیلی عالیه

HTML inside TextView--------------------------------------------------------------------------------
چیجوری html رو داخل تکست ویو نشون بدیم؟ مثلا تگ b و این ها رو
قبلا تکست ویو یک متدی داشت به اسم fromHtml که خب جدیدا یک متد جدید اورده برا این کار و یکم عوض شده

val htmlFormatter = HtmlCompat.fromHtml(item.summary!!, HtmlCompat.FROM_HTML_MODE_COMPACT)
recipeDescTxt.text = htmlFormatter

میایم از کلاس HtmlCompat استفاده میکنیم
دو تا متد داره
toHtml & fromHtml
یکیش این وری تبدیل میکنه یکیشون اون وری
پارامتر اول محتوای html ي ماست که میخوایم نشون بدیم

پارامتر دوم میپرسه به چه شکلی میخوای من اینو تبدیل کنم؟
مربوط به تگ ها و این هاست و زیاد تو حوزه تخصص ما نیست و بیشتر کار فرانت کاراست

حالا ممکنه تگ a داشته باشه که باید کلیکم بخوره
خود تکست ویو به صورت پیش فرض اگه یک موردی به صورت لینک دار باشه میاد اون لینک رو مشخس میکنه
مخصوصا اینجا که ما داریم از اچ تی ام ال استفاده میکنیم
مثلا رنگش رو عوض کنه و این ها

ما الان میخوایم بهش بگیم اون چیزایی که مربوط به لینک هست رو رنگشو عوض نکن
چون پیش فرض میاد رنگ آبی میکنه لینکا رو
ما با اتریبیت زیر بهش میگیم که این  کارو نکنه و رنگ دلخواه خودمون رو بهش میدیم
   android:textColorLink="@color/dolphinGray"

Cash data-------------------------------------------------------------------کش کردن دیتا در اپلیکیشن
تا اینجای کار صفحه اول ما برای حالتی که ایترنت داریم کامل شده
حالا میخوایم شرایطی رو پیاده سازی کنیم که اینترنت وصل نیست
در این حالت باید به جای نشان دادن ارور قطعی اینترنت باید اطلاعات رو از قبل لود کنیم
یک بار که کاربر وارد اپلیکیشن شد و اطلاعات رو گرفت
بدون اینکه کاربر بفهمه ما باید این رو توی دیتابیس ذخیره کنیم
حتما حتما نیاز به دیتابیس داریم و کار دیتا استور و شرد پرفرنس هم نیست
میشه به صورت فایل هم ذخیره کرد که توصیه نمیشه چون سرعت رید و رایتش نسبت به دیتابیس کمه
دردسرهای خاص خودش هم داره

کلا سازو کار کش کردن چیه؟
شما زمانی که میخواید یک چیز به خصوصی رو کش کنید
مثلا برای کش کردن عکس ما از سیستم کش خود کتابخونه استفاده کرده بودیم
ولی به طور کلی ساز و کار کش حالت های مختلفی داره
فقطم توی اندروید نیست این کانسپت کش کردن. توی وب و و ویندوز و ای او اس و سایر پلتفرم ها هست
حالت های مختلف کش کردن خیلی بحث عمیقیه و دانش عمیقی لازم داره که ما کاری نداریم

اکثر اپلیکیشن ها مثل تلگرام و اینستاگرام از دیتابیس برای کش کردن اطلاعات استفاده میکنن
سیستم خیلی بهینه و خوبیه

1- Entity
یک دیتا کلاس تعریف میکنیم و یک آیدی میدیم بهش
و به جای اینکه بقیه فیلدها رو تک به تک اجرا کنیم
 میایم پارامتر دومش رو ریسپانسی که از سرور میاد قرار میدیم
بعدا بنا به شرایط یا این ریپانس مورد نظر از سرور تامین میشه یا از دیتابیس لوکال

سوال؟
حالا از کجا بفهمیم این رسپانسی که ذخیره کردیم مال پاپیلار است یا ریسنت؟
جواب:
از روی آیدی میفهمیم
ما هر چند تا چیز که بخوایم میتونیم داخل تیببل خیره کنیم. درسته؟
ولی ما نمیخوایم کلی چیز ذخیره کنیم که.
اون رسپانسی که داریم ذخیره میکنیم خودش شامل آیدی و لیست و همه چیز هست
ما میایم میگیم من به صورت ذهنی تیبلم رو به دو بخش تقسیم میکنم
اولین بخشش مربوط به پاپیولار - ایندکس ۰
دومین بخشش ریسنت - ایندکس ۱
پس من ای تیبل رو به دو قسمت توی ذهم تقسیم میکنم چون ریسپانس های این ها کاملا یکسانه
بعد اینا قابلیت اورراید داره دیکه. هی رو همون ایندکس مینویسیم باز ریسپانس جدید رو


آیدی رو در نتیجه پرایمری کی میکنیم
ولی نمیخوایم اتو جنریت باشه و میخوایم دست خودمون باشه

2- Dao
چرا اسم کلاس داعو رو گذاشتیم RecipeAppDao ?
چون فقط مختص یک تیبل خاص نیست
میتونیم چندین تیبل داشته باشیم توی این اپ و همه شون هم با همین داعو مدیریت میشه
برای کل اپلیکیشن ماست

ما میدونیم سناریوی کلی ما اینه:
یک صفحه رسپی داریم که قراره کش بشه
یک صفحه فیوریت داریم که قراره کش بشه
یک صفحه دیتیل داریم که قراره کش بشه
هر کدوم از اینا مدل های مختلفی دارن
ولی همه اینا یک دیتابیس و یک داعو خواهند داشت
فقط انتیتی یا تیبل های مختلفی دارن

ما صد تا انتیتی هم که داشته باشیم یک داعو و یک دیتابیس داریم
نیاید اینا رو چند تا بسازید به ازای هر انتیتیی

3- Type Converters
یک نکته خیلی مهمی که وجود داره اینه که
 روم به ما این اجازه رو نمیده که هر چیزی که دلمون میخواد رو توی دیتابیس ذخیره کنیم
مثلا این مدلی که ما الان تعریف کردیم توی دیتابیس روم وجود نداره
توی دیتابیس روم ما به صورت پیش فرض فقط میتونیم از دیتاتایپ های پایه ای واصلی استفاده کنیم
حالا من یک دیتا تایپ کاستوم دارم برای خودم. باید چیکار کنم؟
اصلاحا باید اینو کانورت کنیم و از تایپ کانورترهای مربوط به روم استفاده کنیم
روم برای این بخش قبلا فکر کرده

حالا سناریومون چیه؟
من اول از همه باید این دیتا تایپ رو تبدیل کنم به استرینگ
چرا استرینگ؟
یعنی میایم به کمک جیسون محتواشو تبدیل به یک استرینگ میکنم
در داخل استرینگ نگه میدارم که یکی از دیتا تایپ های اصلی روم است
اینجوری ساختارشم حفظ میشه ولی دیتا تایپشم استرینگ و قابل ذخیره تو روم میشه

برای استفاده ازش باید چیکار کنم؟
دوباره به یک متد دیگه ای هم نیاز دارم
 که اون چیزی که در قالب استرینگ ذخیره کردم رو به صورت جیسون بکشم بیرون
  و هر جا که دلم بخواد هر فیلدیش رو استفاده کنم

من این تایپ کانورتر رو در قالب یک کلاس مینویسم...

4- Type Converter
exportSchema = false
یعنی خروجی جیسون از کل دیتابیس نگیر

سوال:
حالا این تایپ کانورترم رو کجا باید تعریف کنم؟ به کدوم قسمت بدمش؟
جواب:
به همین کلاس دیتابیس
میگیم تویی که داری با این شرایط و این ها دیتابیس من رو میسازی
حواست باشه توی این انتیتی که داری میسازی
من یک دیتا تایپ کاستومی دارم که برای روم تعریف نشده

به این ترتیب تمام کانورترهای من رو خواهد شناخت و وساپورت میکنه

5- DataSource
ریپازیتوری تصمیم میگرفت که این اطلاعات از کجا بیاد
و قبل از اون نیاز به دیتاسورس داشتیم که مطالب بخش آنلاین یا آفلاین رو تامین میکرد
ما تا الان فقط دیتاسورس ریموت داشتیم چون فقط از سرور تامین میشد اطلاعاتمون

6- Repository
ریپازیتوری رجیستر که نیازی به لوکال ندارد همچنان
میریم سر ریپازیتوری رسپی که قراره لوکال رو بهش اضافه کنیم
{رجیستر رو به روش قدیمی و رسپی رو به روش جدید نوشته بودیم}

7- ViewModel
ما یک متد سیو (رایت) میخوایم و یک متد رید
متد سیو ما پرایویت خواهد بود. چرا؟
چون تو همین ویومدل سیو را هندل میکنیم. به فرگمنت و اکتیویتی ما ربطی نداره.
بلافاصبه بعد اینکه ریسپانس api اومد سیو رو انجام میدیم

برای رید کردن:
یک لایو دیتا خواهیم داشت که اطلاعات لود شده از دیتابیس رو داخلش میریزیم
چون ما از دیتابیس به صورت لیست فلو میخوندیم و الان لایو دیتا میخوایم با asLiveData دیتای دریافتی رو تبدیل میکنیم

ما برای سیو کردن دو تا متد مینویسیم که به اصول سالید پایبند باشیم
چون هر متد فقط یک کار باید انجام دهد
متد savePopular که یک انتیتی میگیره و سیو رو انجام میده از طریق ریپازیتوری
متد offlinePopular که ریسپانس رو میگیره و انتیتی رو میسازه و پاس میده به متد سیو
یادآوری:
ما ایندکس 0 را برای پاپیولار در نظر گرفتیم پس به صورت دستی آیدی رو همیشه صفر میدیم

دیتا رو از لایودیتای پاپولار میخونیم که مطمعن باشیم ریسپانس دیتا داره و ارور و اینا نگرفتیم
نال بودن رو هم چک میکنیم حتما

8- Fragment
سناریوی من اینه:
قبلا تا میومدیم سریع api رو کال میکردیم و دیتا رو نشون میدادیم بعدش
الان سناریوی من اینه
اول چک میکنه اگر اطلاعات توی دیتابیس من موجود بود
اطلاعات رو از دیتابیس میخونه
در صورتی که دیتابیس خالی بود و اطلاعاتی توش نبود
میاد از سرور میخونه

کدهای مربوط به این قسمت را داخل متد getPopularData در فرگمنت هندل میکنیم

نکته مهم در مورد لایو دیتا:
اگر با لایو دیتا کار کرده باشید
زمانی که دارید با لایو دیتا کار میکنید و چندین حالت مختلف دارید مثل اینجا
اکه لاگ بذارید میبینید هر بار مثلا دیتای جدید داخل دیتابیس ذخیره میشه
میاد یه دور دوباره از لایودیتای دیتابیس دیتا رو میخونه
یعنی این اتفاقیه که می افته تو اولین ورود به اپ:
چون دیتابیس خالیه api صدا زده میشه
دیتا از سرور لود میشه
دیتا توی دیتابیس ریخته میشه
دیتا از لایودیتای دیتابیس لود میشه
چون دیتابیس دیتای جدید توش ذخیره شده  و این ماهیت لایو دیتا هست
که خب یک کار اضافه و نالازمیه این

برای جلوگیری از این حالت باید چیکار کنیم؟

Single Observe Live Data------------------------------
وقتی ابزرور عادی داریم خب این دایما در حال گوش دادن و اجرای کده
بعضی وقتا نیاز داریم اون ایونت ما یک بار اتفاق بیفته

برای این منظور توی اپ میایم یک اکستنشنی رو مینویسیم
fun <T> LiveData<T>.onceObserve(owner: LifecycleOwner, observe: Observer<T>) {
    observe(owner, object : Observer<T> {
        override fun onChanged(t: T) {
            removeObserver(this)
            observe.onChanged(t)
        }
    })
}

اولا که جنریک تعریفش میکنیم چون نمیدونیم با چه تایپ دیتایی قراره کار کنیم
روی لایو دیتا هم قراره بنویسیم اینو

نکته:
میدونیم که میتونیم اکستنشن رو روی هر چیزی بنویسیم یا نه اون چیز رو به عنوان وردی بدیم بهش اصلا
حالا فرقش چیه؟
فرقش اینه وقتی روی چیزی مینویسیم فقط روی اون چیز بهمون پیشنهاد میده اون اکستنشن رو
حالا تصممیم با منه. میخوام هر جا روی هر چیزی اون ساجسشن رو ببینم
یا فقط مثلا تو کار با چیزای خاص

پارامترها:
زمانی که از لایو دیتا استفاده میکنیم دو تا پارامتر ورودی از ما میگیره
یک owner و یک observe که اینترفیس است

خب بعد این ابزرو ما اول میگه اونر را بده به من
و بعد از طریق کلمه کلیدی آبجکت ما به اینترفیس دسترسی پیدا میکردیم
{عملا معادل همون نیو تو جاوا هست}
بعد از ما میخواد متد onChanged را ایمپلمنت کنیم

این آن چنج همون اینترفیسیه که با هر بار تغییر توی لایو دیتا صدا زده میشه

ما بهش میگیم قبل از انجام هر کاری این ابزرور جاری که من دارم باش کار میکنم را ریموو کن
دیس به همین ابزرور جاری اشاره داره
بعد بیا اون کارایی که باید رو انجام بده
پس این بعد یک بار اجرای کدش عملا خاموش میشه

حالا فقط کافیه به جای ابزرو معمولی از این متد وانس ابزرو خودمون استفاده کنیم. *ـــ*

----------------------------------------
بهتره سناریوی شما طوری باشه که اگه اینترنت بود اولویت لود با سرور باشه
ما اینجا هیچ اولویتی در این زمینه اعمال نکردیم

Bottom Sheet dialog fragment using navigation component---------------------------------------------
میریم توی فایل نویگشین اد میکنیم فرگمنت منو رو
ولی تگش به جای فرگمنت دیالوگ هست
چون میخوایم به صورت باتم شیت دیالوگ و ویژگی های و سازوکار های دیالوگ باز شه
یک اکشن گلوبال هم براش میسازیم
ولی کلا انیمیشن هاش رو برمیداریم چون خودش داره
چون حالت فید رو  نمیخوایم

خیلی راحت با خط کد زیر باز میشه
navHost.navController.navigate(R.id.action_to_menu)

Initialize ViewModel without Kotlin delegates-------------------------------------------------------
گاهی وقتا میخوایم ویومدلمون را جایی اینیشیالایز کنیم که به کاتلینن دلیگیت ها دسترسی نداریم
یا مثلا داخل کلاس های خاص هستیم که به کانتکس دسترسی نداریم
باید به روش قدیمی تر انجام بدیم
این کار رو توی فرگمنت منو انجام دادیم

میایم توی onCreate تعریفش میکنیم
این مربوط به لایف سایکل فرگمنت هست
که برای بار اولی که ساخته میشه onCreate ش صدا زده میشه
onCreateView & onViewCreate ?
تو اینا نمیاریم چون اینا مربوط به ویو هست
نمیخوام با هر بار ساخته شدن ویو این ویومدل من دوباره ساخته بشه

viewModel = ViewModelProvider(requireActivity())[MenuViewModel::class.java]

نکته ۱ :
حتما از پروایدر استفاده کنید نه پروایدرز. دومی دپریکیت شده

نکته ۲ :
اونر مورد نظر رو بهش بدید اینجا اکتیویتی هست

تکته ۳ :
حالت لیست مانند میگیره از ما

Define Views Dynamically----------------------------------------------------------------------------
توی منو فرگمنت این کار رو انجام دادیم
هر آنچه که توی xml هست رو ما میتونیم به صورت داینامیک هم تعریف کنیم
خیلی سخته چون خودمون باید هندل کنیم کجا وصل شه چقد فاصله بگیره اینا

برای تعریف ویو به صورت داینامیک حتما نیاز به کانتکس داریم
          val chip = Chip(requireContext())
{اگه یادت باشه کاسستوم ویو ها دو تا سازنده دارن که اولی فقط کانتکس میگیره و دومی کانتکس و اترییوت}

بعد میایم یک شیپ رو به صورت داینامیک درست میکنیم که بک گراند چیپ ما هست
            val drawable = ChipDrawable.createFromAttributes(requireContext(), null, 0, R.style.DarkChip)
پارامتر اول کانتکس هست که میدیم بهش
پارامتر دوم اتریبیوتسش هست که نال میدیم.
اتریبیوت برای حالتی هست که
اگه تا الان کتابخونه های مربوط به ویو رو اضافه کرده باشید
میبینید یه سری اتریبیوت ها با اپ شروع میشه
قضیه ش چیه؟
همون ویژگی هاست که توی فایل attr ذخیره میکنیم
و توی کاستوم ویو ویژگی های شخصی اون ویو میشن
اگه بخوایم اونا رو میتونیم اینجا بهش بدیم
پارامتر سوم استایل های مربوط به این اترریبیوت هاست که فعلا لازم نداریم
پارامتر چهارم هم این استایلی هست که ما میخوایم بدیم بهش

حالا چیپ یک اتریبیوتی داره که به ما اجازه میده دراابل ست کنیم روش
            chip.setChipDrawable(drawable)

مثلا میشه رنگ متن رو هم عوض کرد
            chip.setTextColor(ContextCompat.getColor(requireContext(), R.color.white))

حالا میخوایم آیدی براش در نظر بگیریم
چون برای ذخیره کردنش به آیدی و نیمش نیاز داریم
اسم همون متن داخل چیپ هست که برای کال کردن api بهش نیاز داریم
آیدی رو میخوایم برای اینکه دفعه بعد که اومدیم توی اپ میخوایم سلکت شده مونده باشه اون چیپ خاص
            chip.id = chipCounter++
            chip.text = it

کلا زمانی که میخوایم ویوها رو به صورت داینامیک تعریف کنید
یک  حالتی دارن اکثر ویوها به اسم اد ویو
چیپ گروپ هم یک جور ویو گروپ است
چون یک سری ویوی دیگه رو داخل خودش نگه میداره
            view.addView(chip)

Communicate between fragments-----------------------------------------------------------------------
برقراری ارتباط بین دو تا فرگمنت
مثلا یک سری اطلاعات در فرگمنت A ذخیره بشن که به واسطه ذخیره شدن این اطلاعات و تغییر در فرگمنت B هم آپدیت اعمال شود
یعنی زمانی که در فرگمنت منو روی دکمه سابمیت میزنیم دو تا اتفاق می افته:
1-
اطلاعات سلکت شده ذخیره میشن که دفعه بعد که برگشتیم سلکت مونده باشن
2-
اوتوماتیک جای دیگه ای هم آپدیت میشه برای من
(فرگمنت هوم آپدیت میشه)

کدهای مربوط به سیو کردن و رید کردن رو توی ریپازیتوری و ویومدل منو نوشتیم

با استفاده از setOnCheckedStateChangeListener میایم آیدی و تکست چیپ کلیک شده رو به دست میاریم
این آیدی و تکست سلکت شده رو یک جایی در صفحه نگهداری میکنیم

زمانی که روی دکمه سابمیت کلیک شد
1-
اطلاعات چیپ های سلکت شده رو داخل دیتا استور سیو میکنیم
2-
میخوایم زمانی که با کلیک روی دکمه سابمیت این فرگمنت بسته شد اطلاعات در هوم آپدیت شه
نمیخوایم وقتی معمولی بسته میشه آپدیتی صورت بگیره
برای هندل کردن این موضوع چیکار میکنیم
ما میایم یک متغیر بولین رو سمت هوم ارسال میکنیم
بعد میگیم اگه این متغیر من مقدار ترو داشت بیا آپدیت رو انجام بده
به این منظور میایم یک اکشنی رو از منو به هوم رسم میکنیم
لازم هم نیست گلوبال باشه
اطلاعات مورد نظر رو هم توسط آرگیومنت میفرستیم
مقدار دیفالت ولیو  فالس رو هم روش ست میکنیم
findNavController().navigate(MenuFragmentDirections.actionMenuFragmentToRecipeFragment().setIsUpdated(true))

کارهایی که باید توی فرگمنت رسپی انجام بدیم:
1-
قبلا میومدیم کوعری های صفحه را برای کال کردن api با دو تا مقدار ثابت میزدیم
حالا میخوایم از مقادبر سلکت شده توی منو استفاده کنیم
از کجا به این مقادیر دسترسی پیدا کنیم؟
رید کردن از دیتاسورس
چیجوری به متد مربوطه دست پیدا کنیم؟
از طریق ریپازیتوری منو

بعد اطلاعات دیتا استور را کالکت میکنیم
هر موقع آپدیت شه دسته بندی ما هم آپدیت میشه...

2-
سمت فرگمنت جایی که ریسنت دیتا رو پر میکردیم و تصمیم میگرفتیم باید از کش بخونیم یا سرور
اینجا میایم یک شرط جدید به شرط های قبلی اضافه میکنیم
         if (database.isNotEmpty() && database.size > 1 && !args.isUpdated)
یعنی در صورتی که آرگومان با مقدار ترو داشتیم هم اجازه نداری از دیتابیس بخونی

اصلاح باگ پاپ کردن توی فرگمنت رسپی--------------------------------------------------------------------
{یک سری توضیحات راج پاپ کردن صفحه اسپلش هست که کلمه پاپ رو سرج کنید توی همین فایل میاره.}

توی فرگمنت منو که میخواستیم منو رو با دکمه سابمیت ببندیم و برگردیم به فرگمنت رسپی
چون میخواستیم که یک دیتایی بفرستیم اومدیم یک دایرکشن جدید ایجاد کردیم و نویگیت کردیم و آرگومان فرستادیم
خب این یک باگی ایجاد میکنه
هر  تعداد که دکمه سابمیت رو بزنیم هی فرگمنت هوم میاد رو فرگمنت هوم
هی بک بزنیم برمیگرده رو هوم قبلی...

باید چیکار کنیم که این مشکل پیش نیاد؟

اکه یادتون  بیاد توی بک اسپلش گفتیم:
خیلی وقتا میشه زمانی که من بک میزنم این فرگمنته اون پشت میمونه
تو اسپلش اومدیم چیجوری بستیمش؟
findNavController().popBackStack(R.id.splashFragment, true)
با این کد بالا

ولی توی صفحه رسپی نمیتونیم کل اون فرگمنت رو ببندیم که...
چون جزیی از باتم نویگیشن ما هست
پس روش بالا و پاک کردنش از استک کار نمیکنه

پارامترهای متد بالا چیان؟
popBackStack(@IdRes destinationId: Int, inclusive: Boolean)

حالا اگه بریم توی فایل نویگیشن و یک دایرکشن رو انتخاب کنیم
توی منوی popBehavior دو تا آپشن میده به ما
popUpTo
popUpToInclusive
اگه ترو بدیم بهش اون فرگمنت رو توی استک نگهداری نمیکنه

این دو تا دقیقا معادل اون دو تا پارامتر اون متده هستن

حالا پارامتر اولیه میگی وقتی این دیگه در دسترس نیست پاپ بشه به کدوم فرگمنت؟
ما دایرکشن منو به رسپی رو انتخاب میکنیم و پاپ رو میذاریم روی رسپی فرگمنت
و حالت ترو رو هم فعال میکنیم
اینجوری توی بک زدن ممکن بود گاهی منوی پایین بیاد بالا دیگه نمیاد بالا

توی تموک میومدم توی بک زدن دیتا پاس میدادم به جای نویگیشن جدید. هر دو روش اوکیه

ولی روش بالا روش خیلی خیلی خوب توی مدیریت بک زدن ها هست بدون نیاز به کد.....

ارور مربوط به دیتا استور----------------------------------------------------------------------------
E/AndroidRuntime: FATAL EXCEPTION: main
    Process: com.jmzd.ghazal.recipeappmvvm, PID: 32028
    java.lang.IllegalStateException: There are multiple DataStores active for the same file: /data/user/0/com.jmzd.ghazal.recipeappmvvm/files/datastore/register_user_info.preferences_pb. You should either maintain your DataStore as a singleton or confirm that there is no two DataStore's active on the same file (by confirming that the scope is cancelled).

فعلا با سینگلتون کردن اسکوپ ریپازیتوری که با این دیتا استور کار میکرد شاید ارور حل شد
قبلا اسکوپش اکتیویتی ریتیند اسکوپ بود که با رفتن اپ به بک گراند گاهی کرش میکرد اپ
چون توی کار با دیتا استور احتمالا داریم با کانتکس اپلیکیشن که از هیلت گرفتیم کار میکنیم
واسه همین یا باید کانتکسی که بهش میدیم کانتکس اکیتیویتی  باشه
یا باید کروتینش هندل شه
یا کلاس مربوطه هم سینگل تون شه
در غیر این صورت مموری لیک میتونه رخ بده....


Detail Fragment-------------------------------------------------------------------------------------
Retrofit-----------------------------
زمانی که هم path داریم هم query
همیشه اول متغیرهای path رو بنویسید بعد متغیرهای کوعری
repository---------------------------
ریپازیتوری مورد نیاز برای صفحه دیتیل دقیقا همونیه که برای صفحه رسپی استفاده کردیم
یعنی RecipeRepository
چون دقیقا یک لوکال دیتاسورس داره و یک ریموت دیتاسورس
پس از همین استفاده میکنیم

Access Position inside Adapter--------------------------------------------دسترسی به پوزیشن در آداپتر
برای دسترسی به پوزیشن در آداپتر دو ره داریم
1-
داخل onBindViewHolder که دسترسی داریم به عنوان یک پارامتر
2-
از هر جای آداپتر مثلا داخل ویوهلدر adapterPosition را بزنیم هم دسترسی خواهیم داشت
این روش حرفه ای تر هم هست

Send data using Parsable----------------------------------انتقال دیتای کاستوم با استفاده از پارسیلبل
توی صفحه جزییات یک آداپتر استپس داریم
 که در حالت عادی ۳ تا استپ رو بیشتر نشون نمیده و یک showMore نشون میده
 میخوایم وقتی کاربر روی شو مور کلیک کرد یک باتم شیت دیالوگ باز شود و لیست کامل رو نمایش دهد
 برای این کار باید لیست رو براش بفرستیم چون نمیخوایم دیتا رو دوباره لود کنیم
و خب داریم دیتای کاستوم رو میفرستیم نه یه مشت اینت و استرینگ و این ها

نکته تعداد آیتم ها در آداپتر:
اگر بریم دستی توی آداپتر آیتم کانت رو ۳ ست کنیم چه اتفاقی می افته؟
در صورتی که لیستی که به آداپتر میفرستیم کمتر از ۳ آیتم داشته باشد
ارور معروف out of bounds رو میگیریم
اپلیکیشن هم کرش میکند

مراحل انتقال دیتای کاستوم با استفاده از پارسیلبل:
1-
داخل خود فرگمنت اگه بریم داخل addArgument میتونیم ببینیم که علاوه بر اون دیتا تایپ های پایه ای
یک سری گزینه دیگه داره
custom serializable - custom parcelable - custom enum

میتونیم از این ها استفاده کنیم ولی ما میخوایم از یک روش بهتر استفاده کنیم
میایم کلاس رو از نوع پارسیلبل تعریف میکنیم که بتونیم بفرستمیش
پارسیلبلبل در واقع یکی از روش های ارسال و انتقال اطلاعات از یک صفحه به صفحه دیگه هست
بهترین حالت هست

2-
برای استفاده از پارسیلبلبل باید اول به گردلمون بفهمونیم که نیاز به پارسیلبلبل داریم
پس این خط کد رو در قسمت پلاگین های گردل اضافه میکنیم
    id 'kotlin-parcelize'
و پروژه رو سینک میکنیم

3-
الان اگه برگردیم و addArgument رو بزنیم میتونیم custom parcelable رو بزنیم
ولی میگه خب تو الان چیزی از این نو تو پروژه ت نداریا
پس باید بریم کلاس مورد نظرمون رو به پارسیلبلبل تبدیل کنیم

خب ما میخوایم کلاس AnalyzedInstruction رو از ResponseDetail بفرستیم

4-
بالای کلاس مورد نظر انوتیشن  @Parcelize از کاتلین پارسالایز رو اضافه میکنیم
چون یکی هم هست مال اندروید که اون رو نیاز نداریم

5-
بعد از اضافه کردن این انوتیشن باید کل کلاس رو هم از پارسیلبلبل ارث بری کنیم
برای این کار جایی که پرانتز کلاس تموم میشه یک دو نقطه میذاریم و ارث بری میکنیم

6-
حالا به لیست استپ ما گیر میده
چرا؟
چون ما توسط این پارسیلبلبل کردن دوباره میتونیم یک سری دیتاتایپ های مشخص رو بفرستیم
لیست جزو این دیتا تایپ های پایه ای نیست

برای حل این مشکل میایم انوتیشن RawValue رو قبل لیست اضافه میکنیم
حواستون باشه اینم از پکیج کاتلین ایکس باشه نه اندروید چون قبلی هم از پکیج کاتلین بود
تا اینجای کار تبدیل ما با موفقیت انجام شد. حالا بریم ببینیم چطوری باید بفرستیمش بره

7-
navGraph -> select stepsFragment -> add arguments -> custom parcelable -> select class -> choose some name (for example data)
بعد اگه بریم توی کد میینیم کد زیر رو اضافه کرده
   <argument
            android:name="data"
            app:argType="com.jmzd.ghazal.recipeappmvvm.models.detail.ResponseDetail$AnalyzedInstruction" />

8-
حالا دیگه مثل قبل میایم دیتا رو داخل ارگومان های دایرکشن میفرستیم و اون طرف از آرگز دریافت میکنیم

Custom WebView--------------------------------------------------------------------------------------
مثلا میخوایم بگیم جاوا اسکریپت رو ساپورت کن
یا خودش بیاد یک دیتابیسی برای ذخیره اطلاعاتی که سمت جاوا اسکریپت هست در نظر بگیرد
مثلا زوم این و زوم اوت داشته باشیم
لودینگ رو ست کنیم و...

ما یک متدی داریم به اسم ستینگز در وب ویو که آپشن های خیلی زیادی رو به ما میده
میتونیم موارد مختلف رو فعال کنیم باهاش

 settings.javaScriptEnabled = true
 جاوا اسکریپت رو به صورت کامل برای ما ساپورت کنه

 settings.loadWithOverviewMode = true
 دیدید گاهی بعضی صفحات وب رو داخل مرورگرهای داخل اپلیکیشن باز میکنید دفرمه س و فیت صفحه تون نیست؟
 برای اینه که این اتریبییوت رو فعال نکردن
 با فعال کردن این گزینه بدون اینکه اون حالت زوم این و زوم اوت رو بیاره فیت صفحه لود میکنه

 settings.useWideViewPort = true
 توی وب دیدید از یک سری از مدیاها استفاده میشه
 مثلا برای عکس ها و ویدیو و این ها
 اگر این رو ترو نکنید
 مثلا اونجا زده عرض عکس ۵۰ در ۵۰ باشه
 ممکنه تو صفحه ما خیلی کوچیک شه مثلا
 اگر این رو ترو کنیم میاد با نسبت های صفحه خودمون عکس ها رو درست میکنه

 settings.builtInZoomControls = false
 کنترلرهای مربوط به زوم رو نشون نده
 اون مثبت منفیه و این ها که قدیما بیشتر نشون میدادن

 settings.domStorageEnabled = true
 میخوایم ذخیره سازی استوریج رو بهش اجازه بدیم
 ممکنه خود وب بخواد یه سری چیزا رو تو استوریج ذخیره کنه که ما این اجازه رو میدیم

 settings.databaseEnabled = true
 دیتابیس هم داشته باشه وب ویومون و یک دیتابیسی تو کش براش در نظر بگیره و این ها
 این موارد میتونه به سرعت لود صفحه ما خیلی کمک کنه

 webView.webViewClient = WebViewClient()
 ما توی وب ویو میتونیم یک حالتی داشته باشیم که اکثرا بهش میگن کلاینت
 یک کلاینتی رو میتونید در نظر بگیرید که ساختارش رو ببره روی اون کلاینت
 مثلا کروم یک کلاینته و اگه بخوایم از ویژگی های خاص کروم استفاده کنیم میتونیم از کلاینت مربوط به کروم استفاده کنیم
 ما میخوایم از کلاینت وب ویو یعنی از چیزهایی که برای وب ویو کیت در نظر گرفتن استفاده کنم
 یعنی المان هایی که اون وب ویو کلاینت برای کروم در نظر گرفته هم ما بتونیم داشته باشیم اینجا
 {چیزهایی که سمت وب با ویژگی وب کیت مشخص میشه}

 webView.isVerticalScrollBarEnabled = true
 گاهی یک سری باگ هایی تو طراحی هست که مثلا از سمت فرانت اند دولوپره
 مثلا کامل ریسپانسیو نیست و به چپ و راست اسکرول میخوره
 اجازه بدیم این اسکرول چپ و راست ساپورت شه
 نباید اتفاق بیفته ولی ممکنه بیفته

 webView.isHorizontalScrollBarEnabled = true
 حالت عمودی هم ساپورت شه طبیعتا

 وصل کردن پروگرس به وب ویو
 webView.webChromeClient = object : WebChromeClient() {
     override fun onProgressChanged(view: WebView?, newProgress: Int) {

        شرط میذاریم اگر این پروگرسی که داشتیم توی وب ویو هنوز صد نشده بود
        و پروگرس بار خودمون هم گان بود
        بیا ویزیبل کن پروگرس خودمونو
         if (newProgress < 100 && webViewLoading.visibility == View.GONE) {
             webViewLoading.isVisible = true
         }

         درصدشو از وب ویو بگیر
         webViewLoading.progress = newProgress

         وقتی لود کامل شد گان کن
         if (newProgress == 100) {
             webViewLoading.isVisible = false
         }
     }
 }

 در نهایت هم لود کن. تمام
 webView.loadUrl(link)

 ***** نکته خیلی خیلی خیلی مهم بی نهایت مهم *****
 زمانی که دارید از وب ویوها داخل اپلیکیشن خودتون استفاده میکنید و جاوا اسکریپت رو فعال میکنید
 ممکنه جاوا اسکریپت ها یک سری کدهای خیلی سنگینی داشته باشن
 ممکنه کاربر وارد وب ویو شما که میشه با یک لگ خیلی سنگینی رو به رو بشه
 برای برطرف کردن این مورد
 میخوایم از اون حالت سخت افزاری یکم کمک بگیرم
 خط کد زیر را در مانیفست در تگ اپلیکیشن قرار میدیم
 android:hardwareAccelerated="true"
 خیلی خیلی کار با وب ویوی جاوا اسکریپت دار رو سبک میکنه
 همچنین خط کد زیر
 android:largeHeap="true"
 لارج هیپ یعنی چی؟
 حافظه ای که اندروید برای اپلیکیشن ما در نظر میگیره در قالب هیپه
 مقدار اونو یه خرده بیشتر میکنیم
 منابع یه خرده بیشتر که باشه کمتر به لگ میخوریم
 یکم رم بیشتر بمون اختصاص میده
 البته ما کد سمت خودمون رو بهینه مینویسیم
 ولی وب ویو سمت ما نیست
 ما درخواست یکم منابع سخت افزاری بیشتر میکنیم که با لگ رو به رو نشیم

 --------------فعال کردن ساپورت http--------------
 android:usesCleartextTraffic="true"

cache detail data-------------------------------------------------------کش کردن اطلاعات در صفحه دیتیل
مراحل کش کردن دیتا رو قبلا انجام دادیم برای صفحه رسپی
اینجا یک مرور کلی خواهیم داشت

1- create entity
برای ساخت انتیتی دو تا فیلد در نظر میگرفتیم
یکی آیدی که اتو جنریت هم نبود
یکی هم مدل ریسپانسمون
ما همون آیدی رسپی رو به آیدی میدیم. چرا؟
چون بعدا میخوایم بر اساس آیدی چک کنیم که برو ببین فلان چیز توی دیتابیس من هست یا نه
اگر نیست api را صدا بزن

2- type converter
ما داریم از کلاس کاستومی استفاده میکنیم که توی روم تعریف نشده
پس به تایپ کانورتر نیاز داریم
